// Generated by dart2js (NullSafetyMode.sound, csp, deferred-serialization, intern-composite-values), the Dart to JavaScript compiler version: 2.19.6.
self.$__dart_deferred_initializers__ = self.$__dart_deferred_initializers__ || Object.create(null);
$__dart_deferred_initializers__.current = function(hunkHelpers, init, holdersList, $) {
  var B = {
    SnackBar$(action, animation, backgroundColor, behavior, clipBehavior, closeIconColor, $content, dismissDirection, duration, elevation, key, margin, onVisible, padding, shape, showCloseIcon, width) {
      return new B.SnackBar($content, backgroundColor, elevation, margin, padding, width, shape, behavior, action, showCloseIcon, closeIconColor, duration, animation, onVisible, dismissDirection, clipBehavior, key);
    },
    SnackBar: function SnackBar(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16) {
      var _ = this;
      _.content = t0;
      _.backgroundColor = t1;
      _.elevation = t2;
      _.margin = t3;
      _.padding = t4;
      _.width = t5;
      _.shape = t6;
      _.behavior = t7;
      _.action = t8;
      _.showCloseIcon = t9;
      _.closeIconColor = t10;
      _.duration = t11;
      _.animation = t12;
      _.onVisible = t13;
      _.dismissDirection = t14;
      _.clipBehavior = t15;
      _.key = t16;
    },
    _SnackBarState: function _SnackBarState(t0) {
      var _ = this;
      _._wasVisible = false;
      _._widget = null;
      _._debugLifecycleState = t0;
      _._framework$_element = null;
    },
    _SnackBarState_build_closure0: function _SnackBarState_build_closure0(t0) {
      this.context = t0;
    },
    _SnackBarState_build_closure: function _SnackBarState_build_closure(t0) {
      this.context = t0;
    },
    _SnackBarState_build_closure1: function _SnackBarState_build_closure1(t0) {
      this.heightAnimation = t0;
    },
    _SnackbarDefaultsM2: function _SnackbarDefaultsM2(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11) {
      var _ = this;
      _.___SnackbarDefaultsM2__theme_F = t0;
      _.___SnackbarDefaultsM2__colors_F = t1;
      _.backgroundColor = t2;
      _.actionTextColor = t3;
      _.disabledActionTextColor = t4;
      _.contentTextStyle = t5;
      _.elevation = t6;
      _.shape = t7;
      _.behavior = t8;
      _.width = t9;
      _.insetPadding = t10;
      _.closeIconColor = t11;
    },
    DismissDirection: function DismissDirection(t0, t1) {
      this.index = t0;
      this._core$_name = t1;
    },
    Dismissible: function Dismissible(t0, t1, t2, t3, t4) {
      var _ = this;
      _.child = t0;
      _.onDismissed = t1;
      _.direction = t2;
      _.resizeDuration = t3;
      _.key = t4;
    },
    _FlingGestureKind: function _FlingGestureKind(t0, t1) {
      this.index = t0;
      this._core$_name = t1;
    },
    _DismissibleState: function _DismissibleState(t0, t1, t2, t3, t4) {
      var _ = this;
      _._moveController = null;
      _.___DismissibleState__moveAnimation_A = $;
      _._resizeAnimation = _._resizeController = null;
      _._dragExtent = 0;
      _._dragUnderway = _._confirming = false;
      _._sizePriorToCollapse = null;
      _._dismissThresholdReached = false;
      _._contentKey = t0;
      _.AutomaticKeepAliveClientMixin__keepAliveHandle = t1;
      _.TickerProviderStateMixin__tickers = t2;
      _.TickerProviderStateMixin__tickerModeNotifier = t3;
      _._widget = null;
      _._debugLifecycleState = t4;
      _._framework$_element = null;
    },
    _DismissibleState__handleDragStart_closure: function _DismissibleState__handleDragStart_closure(t0) {
      this.$this = t0;
    },
    _DismissibleState__handleDragUpdate_closure: function _DismissibleState__handleDragUpdate_closure(t0) {
      this.$this = t0;
    },
    __DismissibleState_State_TickerProviderStateMixin: function __DismissibleState_State_TickerProviderStateMixin() {
    },
    __DismissibleState_State_TickerProviderStateMixin_AutomaticKeepAliveClientMixin: function __DismissibleState_State_TickerProviderStateMixin_AutomaticKeepAliveClientMixin() {
    }
  },
  D, A, C, E, G, H, F, I, J;
  B = hunkHelpers.updateHolder(holdersList[34], B);
  D = holdersList[2];
  A = holdersList[0];
  C = holdersList[74];
  E = holdersList[82];
  G = holdersList[48];
  H = holdersList[54];
  F = holdersList[78];
  I = holdersList[79];
  J = holdersList[1];
  B.SnackBar.prototype = {
    withAnimation$2$fallbackKey(newAnimation, fallbackKey) {
      var t1, _this = this;
      type$.Animation_double._as(newAnimation);
      t1 = _this.key;
      if (t1 == null)
        t1 = fallbackKey;
      return B.SnackBar$(_this.action, newAnimation, _this.backgroundColor, _this.behavior, _this.clipBehavior, _this.closeIconColor, _this.content, _this.dismissDirection, _this.duration, _this.elevation, t1, _this.margin, _this.onVisible, _this.padding, _this.shape, _this.showCloseIcon, _this.width);
    },
    createState$0() {
      return new B._SnackBarState(D._StateLifecycle_0);
    }
  };
  B._SnackBarState.prototype = {
    initState$0() {
      var t1, t2;
      this.super$State$initState();
      t1 = this._widget.animation;
      t1.toString;
      t2 = type$.void_Function_AnimationStatus._as(this.get$_onAnimationStatusChanged());
      t1.didRegisterListener$0();
      t1 = t1.AnimationLocalStatusListenersMixin__statusListeners;
      t1.$ti._precomputed1._as(t2);
      t1._isDirty = true;
      D.JSArray_methods.add$1(t1._list, t2);
    },
    didUpdateWidget$1(oldWidget) {
      var t1, t2, _this = this;
      type$.SnackBar._as(oldWidget);
      _this.super$State$didUpdateWidget(oldWidget);
      t1 = oldWidget.animation;
      if (_this._widget.animation != t1) {
        t2 = _this.get$_onAnimationStatusChanged();
        t1.removeStatusListener$1(t2);
        t1 = _this._widget.animation;
        t1.toString;
        type$.void_Function_AnimationStatus._as(t2);
        t1.didRegisterListener$0();
        t1 = t1.AnimationLocalStatusListenersMixin__statusListeners;
        t1.$ti._precomputed1._as(t2);
        t1._isDirty = true;
        D.JSArray_methods.add$1(t1._list, t2);
      }
    },
    dispose$0() {
      this._widget.animation.removeStatusListener$1(this.get$_onAnimationStatusChanged());
      this.super$State$dispose();
    },
    _onAnimationStatusChanged$1(animationStatus) {
      switch (type$.AnimationStatus._as(animationStatus).index) {
        case 0:
        case 1:
        case 2:
          break;
        case 3:
          this._widget.toString;
          this._wasVisible = true;
          break;
      }
    },
    build$1(context) {
      var snackBarBehavior, width, isFloatingSnackBar, horizontalPadding, padding, heightAnimation, fadeInAnimation, fadeOutAnimation, actionTextPainter, t2, margin, snackBarWidth, actionLineOverflow, t3, snackBar, elevation, backgroundColor, shape, snackBarTransition, _this = this, _null = null,
        mediaQueryData = context.dependOnInheritedWidgetOfExactType$1$0(type$.MediaQuery).data,
        theme = A.Theme_of(context),
        colorScheme = theme.colorScheme,
        snackBarTheme = theme.snackBarTheme,
        isThemeDark = colorScheme.brightness === D.Brightness_0,
        buttonColor = isThemeDark ? colorScheme.primary : colorScheme.secondary,
        defaults = new B._SnackbarDefaultsM2(A.Theme_of(context), A.Theme_of(context).colorScheme, _null, _null, _null, _null, 6, _null, _null, _null, _null, _null),
        brightness = isThemeDark ? D.Brightness_1 : D.Brightness_0,
        t1 = colorScheme.onPrimary,
        effectiveTheme = theme.copyWith$1$colorScheme(A.ColorScheme$(defaults.get$backgroundColor(defaults), brightness, colorScheme.onError, _null, _null, _null, colorScheme.background, colorScheme.error, _null, _null, colorScheme.primary, _null, colorScheme.secondary, _null, colorScheme.surface, _null, _null, _null, _null, _null, t1, _null, t1, _null, buttonColor, _null, colorScheme.onSecondary, _null, colorScheme.onSurface, _null, _null, _null, _null)),
        contentTextStyle = snackBarTheme.contentTextStyle;
      if (contentTextStyle == null)
        contentTextStyle = defaults.get$contentTextStyle();
      _this._widget.toString;
      snackBarBehavior = defaults.get$behavior();
      _this._widget.toString;
      width = snackBarTheme.width;
      defaults.get$showCloseIcon();
      isFloatingSnackBar = snackBarBehavior === D.SnackBarBehavior_1;
      horizontalPadding = isFloatingSnackBar ? 16 : 24;
      t1 = _this._widget;
      padding = t1.padding;
      padding = new A.EdgeInsetsDirectional(horizontalPadding, 0, horizontalPadding, 0);
      t1 = t1.animation;
      t1.toString;
      heightAnimation = A.CurvedAnimation$(D.Cubic_ifx, t1, _null);
      t1 = _this._widget.animation;
      t1.toString;
      fadeInAnimation = A.CurvedAnimation$(C.Interval_jzi, t1, _null);
      t1 = _this._widget.animation;
      t1.toString;
      A.CurvedAnimation$(C.Interval_0Q9, t1, _null);
      t1 = _this._widget.animation;
      t1.toString;
      fadeOutAnimation = A.CurvedAnimation$(C.Interval_8qt, t1, E.Threshold_0);
      t1 = _this._widget.animation;
      t1.toString;
      A.CurvedAnimation$(C.Cubic_gWH, t1, E.Threshold_0);
      _this._widget.toString;
      actionTextPainter = A.TextPainter$(_null, _null, 1, _null, A.TextSpan$(_null, A.Theme_of(context).textTheme.labelLarge, ""), D.TextAlign_4, D.TextDirection_1, _null, 1, D.TextWidthBasis_0);
      actionTextPainter.layout$0();
      t1 = actionTextPainter.get$width(actionTextPainter);
      t2 = actionTextPainter._paragraph;
      Math.ceil(t2.get$height(t2));
      _this._widget.toString;
      margin = snackBarTheme.insetPadding;
      if (margin == null)
        margin = defaults.get$insetPadding();
      _this._widget.toString;
      snackBarWidth = mediaQueryData.size._dx - (margin.left + margin.right);
      actionLineOverflow = (t1 + 0 + 0) / snackBarWidth > 0.25;
      t1 = type$.JSArray_Widget;
      t2 = A._setArrayType([], t1);
      t3 = _this._widget;
      t3.toString;
      contentTextStyle.toString;
      t3 = A._setArrayType([G.Expanded$(A.Container$(_null, A.DefaultTextStyle$(t3.content, _null, _null, D.TextOverflow_0, true, contentTextStyle, _null, _null, D.TextWidthBasis_0), D.Clip_0, _null, _null, _null, _null, _null, C.EdgeInsets_0_14_0_14, _null, _null), 1)], t1);
      if (!actionLineOverflow)
        D.JSArray_methods.addAll$1(t3, t2);
      if (actionLineOverflow)
        t3.push(A.SizedBox$(_null, _null, snackBarWidth * 0.4));
      t1 = A._setArrayType([A.Row$(t3, D.CrossAxisAlignment_2, D.MainAxisAlignment_0, D.MainAxisSize_1)], t1);
      if (actionLineOverflow)
        t1.push(new A.Padding(C.EdgeInsets_0_0_0_14, A.Row$(t2, D.CrossAxisAlignment_2, D.MainAxisAlignment_1, D.MainAxisSize_1), _null));
      snackBar = new A.Padding(padding, H.Wrap$(F.WrapAlignment_0, t1, F.WrapCrossAlignment_0, D.Axis_0, 0, 0), _null);
      if (!isFloatingSnackBar)
        snackBar = A.SafeArea$(true, snackBar, D.EdgeInsets_0_0_0_0, false);
      _this._widget.toString;
      elevation = snackBarTheme.elevation;
      if (elevation == null) {
        t1 = defaults.elevation;
        t1.toString;
        elevation = t1;
      }
      backgroundColor = snackBarTheme.backgroundColor;
      if (backgroundColor == null)
        backgroundColor = defaults.get$backgroundColor(defaults);
      _this._widget.toString;
      shape = snackBarTheme.shape;
      if (shape == null)
        shape = isFloatingSnackBar ? defaults.get$shape(defaults) : _null;
      t1 = mediaQueryData.accessibleNavigation;
      snackBar = A.Material$(D.Duration_200000, _null, new A.Theme(effectiveTheme, t1 || false ? snackBar : A.FadeTransition$(false, snackBar, fadeOutAnimation), _null), D.Clip_0, backgroundColor, elevation, _null, _null, shape, _null, _null, D.MaterialType_0);
      if (isFloatingSnackBar)
        snackBar = A.SafeArea$(false, width != null ? A.Container$(_null, snackBar, D.Clip_0, _null, _null, _null, _null, new A.EdgeInsets(0, margin.top, 0, margin.bottom), _null, _null, width) : new A.Padding(margin, snackBar, _null), D.EdgeInsets_0_0_0_0, false);
      t2 = _this._widget;
      snackBar = A.Semantics$(_null, _null, new B.Dismissible(snackBar, new B._SnackBarState_build_closure(context), t2.dismissDirection, _null, C.ValueKey_dismissible), true, _null, _null, false, _null, _null, _null, _null, _null, _null, true, _null, _null, _null, _null, _null, new B._SnackBarState_build_closure0(context), _null, _null, _null, _null, _null, _null, _null, _null, _null, _null);
      if (t1)
        snackBarTransition = snackBar;
      else if (isFloatingSnackBar && true)
        snackBarTransition = A.FadeTransition$(false, snackBar, fadeInAnimation);
      else
        snackBarTransition = A.AnimatedBuilder$(heightAnimation, new B._SnackBarState_build_closure1(heightAnimation), snackBar);
      t1 = t2.content.toString$0(0);
      return A.Hero$(A.ClipRect$(snackBarTransition, _this._widget.clipBehavior, _null), "<SnackBar Hero tag - " + t1 + ">", true);
    }
  };
  B._SnackbarDefaultsM2.prototype = {
    get$backgroundColor(_) {
      var t2,
        t1 = this.___SnackbarDefaultsM2__theme_F;
      t1 === $ && A.throwLateFieldNI("_theme");
      t2 = this.___SnackbarDefaultsM2__colors_F;
      if (t1.colorScheme.brightness === D.Brightness_1) {
        t2 === $ && A.throwLateFieldNI("_colors");
        t1 = t2.onSurface.value;
        t2 = A.Color_alphaBlend(A.Color$fromARGB(204, t1 >>> 16 & 255, t1 >>> 8 & 255, t1 & 255), t2.surface);
        t1 = t2;
      } else {
        t2 === $ && A.throwLateFieldNI("_colors");
        t1 = t2.onSurface;
      }
      return t1;
    },
    get$contentTextStyle() {
      var t1 = this.___SnackbarDefaultsM2__theme_F;
      t1 === $ && A.throwLateFieldNI("_theme");
      return A.ThemeData_ThemeData(t1.colorScheme.brightness === D.Brightness_1 ? D.Brightness_0 : D.Brightness_1, null).textTheme.titleMedium;
    },
    get$behavior() {
      return I.SnackBarBehavior_0;
    },
    get$actionTextColor() {
      var t1 = this.___SnackbarDefaultsM2__colors_F;
      t1 === $ && A.throwLateFieldNI("_colors");
      return t1.secondary;
    },
    get$disabledActionTextColor() {
      var t2,
        t1 = this.___SnackbarDefaultsM2__colors_F;
      t1 === $ && A.throwLateFieldNI("_colors");
      t2 = this.___SnackbarDefaultsM2__theme_F;
      t2 === $ && A.throwLateFieldNI("_theme");
      t1 = t1.onSurface.value;
      return A.Color$fromARGB(D.JSNumber_methods.round$0(255 * (t2.colorScheme.brightness === D.Brightness_1 ? 0.38 : 0.3)), t1 >>> 16 & 255, t1 >>> 8 & 255, t1 & 255);
    },
    get$shape(_) {
      return D.RoundedRectangleBorder_27D1;
    },
    get$insetPadding() {
      return C.EdgeInsets_15_5_15_10;
    },
    get$showCloseIcon() {
      return false;
    },
    get$closeIconColor() {
      var t1 = this.___SnackbarDefaultsM2__colors_F;
      t1 === $ && A.throwLateFieldNI("_colors");
      return t1.onSurface;
    }
  };
  B.DismissDirection.prototype = {
    _enumToString$0() {
      return "DismissDirection." + this._core$_name;
    }
  };
  B.Dismissible.prototype = {
    createState$0() {
      var _null = null;
      return new B._DismissibleState(new A.LabeledGlobalKey(_null, type$.LabeledGlobalKey_State_StatefulWidget), _null, _null, _null, D._StateLifecycle_0);
    }
  };
  B._FlingGestureKind.prototype = {
    _enumToString$0() {
      return "_FlingGestureKind." + this._core$_name;
    }
  };
  B._DismissibleState.prototype = {
    initState$0() {
      var t1, t2, t3, _this = this;
      _this.super$__DismissibleState_State_TickerProviderStateMixin_AutomaticKeepAliveClientMixin$initState();
      _this._widget.toString;
      t1 = A.AnimationController$(null, D.Duration_200000, null, null, _this);
      t2 = type$.void_Function_AnimationStatus._as(_this.get$_handleDismissStatusChanged());
      t1.didRegisterListener$0();
      t3 = t1.AnimationLocalStatusListenersMixin__statusListeners;
      t3.$ti._precomputed1._as(t2);
      t3._isDirty = true;
      D.JSArray_methods.add$1(t3._list, t2);
      t2 = type$.void_Function._as(_this.get$_handleDismissUpdateValueChanged());
      t1.didRegisterListener$0();
      t3 = t1.AnimationLocalListenersMixin__listeners;
      t3.$ti._precomputed1._as(t2);
      t3._isDirty = true;
      D.JSArray_methods.add$1(t3._list, t2);
      _this._moveController = t1;
      _this._updateMoveAnimation$0();
    },
    get$wantKeepAlive() {
      var t1 = this._moveController;
      if (t1 == null)
        t1 = null;
      else {
        t1 = t1._ticker;
        t1 = t1 != null && t1._ticker$_future != null;
      }
      if (t1 !== true) {
        t1 = this._resizeController;
        if (t1 == null)
          t1 = null;
        else {
          t1 = t1._ticker;
          t1 = t1 != null && t1._ticker$_future != null;
        }
        t1 = t1 === true;
      } else
        t1 = true;
      return t1;
    },
    dispose$0() {
      this._moveController.dispose$0();
      var t1 = this._resizeController;
      if (t1 != null)
        t1.dispose$0();
      this.super$__DismissibleState_State_TickerProviderStateMixin$dispose();
    },
    get$_directionIsXAxis() {
      var t1 = this._widget.direction;
      return t1 === C.DismissDirection_1 || t1 === C.DismissDirection_2 || t1 === C.DismissDirection_3;
    },
    _extentToDirection$1(extent) {
      var t1;
      if (extent === 0)
        return C.DismissDirection_6;
      if (this.get$_directionIsXAxis()) {
        t1 = this._framework$_element.dependOnInheritedWidgetOfExactType$1$0(type$.Directionality);
        t1.toString;
        switch (t1.textDirection.index) {
          case 0:
            return extent < 0 ? C.DismissDirection_3 : C.DismissDirection_2;
          case 1:
            return extent > 0 ? C.DismissDirection_3 : C.DismissDirection_2;
        }
      }
      return extent > 0 ? C.DismissDirection_5 : C.DismissDirection_4;
    },
    get$_overallDragAxisExtent() {
      var t1 = this._framework$_element;
      t1 = t1.get$size(t1);
      t1.toString;
      return this.get$_directionIsXAxis() ? t1._dx : t1._dy;
    },
    _dismissible$_handleDragStart$1(details) {
      var t1, t2, _this = this;
      if (_this._confirming)
        return;
      _this._dragUnderway = true;
      t1 = _this._moveController;
      t2 = t1._ticker;
      if (t2 != null && t2._ticker$_future != null) {
        t1 = t1.__AnimationController__value_A;
        t1 === $ && A.throwLateFieldNI("_value");
        _this._dragExtent = t1 * _this.get$_overallDragAxisExtent() * J.get$sign$in(_this._dragExtent);
        _this._moveController.stop$0(0);
      } else {
        _this._dragExtent = 0;
        t1.set$value(0, 0);
      }
      _this.setState$1(new B._DismissibleState__handleDragStart_closure(_this));
    },
    _dismissible$_handleDragUpdate$1(details) {
      var t1, oldDragExtent, t2, _this = this;
      if (!_this._dragUnderway) {
        t1 = _this._moveController._ticker;
        t1 = t1 != null && t1._ticker$_future != null;
      } else
        t1 = true;
      if (t1) {
        t1 = _this._moveController._ticker;
        t1 = t1 != null && t1._ticker$_future != null;
      } else
        t1 = true;
      if (t1)
        return;
      t1 = details.primaryDelta;
      t1.toString;
      oldDragExtent = _this._dragExtent;
      switch (_this._widget.direction.index) {
        case 1:
        case 0:
          _this._dragExtent = oldDragExtent + t1;
          break;
        case 4:
          t1 = oldDragExtent + t1;
          if (t1 < 0)
            _this._dragExtent = t1;
          break;
        case 5:
          t1 = oldDragExtent + t1;
          if (t1 > 0)
            _this._dragExtent = t1;
          break;
        case 2:
          t2 = _this._framework$_element.dependOnInheritedWidgetOfExactType$1$0(type$.Directionality);
          t2.toString;
          switch (t2.textDirection.index) {
            case 0:
              t1 = _this._dragExtent + t1;
              if (t1 > 0)
                _this._dragExtent = t1;
              break;
            case 1:
              t1 = _this._dragExtent + t1;
              if (t1 < 0)
                _this._dragExtent = t1;
              break;
          }
          break;
        case 3:
          t2 = _this._framework$_element.dependOnInheritedWidgetOfExactType$1$0(type$.Directionality);
          t2.toString;
          switch (t2.textDirection.index) {
            case 0:
              t1 = _this._dragExtent + t1;
              if (t1 < 0)
                _this._dragExtent = t1;
              break;
            case 1:
              t1 = _this._dragExtent + t1;
              if (t1 > 0)
                _this._dragExtent = t1;
              break;
          }
          break;
        case 6:
          _this._dragExtent = 0;
          break;
      }
      if (J.get$sign$in(oldDragExtent) !== J.get$sign$in(_this._dragExtent))
        _this.setState$1(new B._DismissibleState__handleDragUpdate_closure(_this));
      t1 = _this._moveController;
      t2 = t1._ticker;
      if (!(t2 != null && t2._ticker$_future != null))
        t1.set$value(0, Math.abs(_this._dragExtent) / _this.get$_overallDragAxisExtent());
    },
    _handleDismissUpdateValueChanged$0() {
      this._widget.toString;
    },
    _updateMoveAnimation$0() {
      var t2, t3, _this = this,
        end = J.get$sign$in(_this._dragExtent),
        t1 = _this._moveController;
      t1.toString;
      t2 = _this.get$_directionIsXAxis();
      t3 = _this._widget;
      if (t2) {
        t3.toString;
        t2 = new A.Offset(end, 0);
      } else {
        t3.toString;
        t2 = new A.Offset(0, end);
      }
      t2 = type$.Animatable_Offset._as(new A.Tween(D.Offset_0_0, t2, type$.Tween_Offset));
      t3 = type$.Animation_double;
      _this.set$___DismissibleState__moveAnimation_A(type$.Animation_Offset._as(new A._AnimatedEvaluation(t3._as(t3._as(t1)), t2, t2.$ti._eval$1("_AnimatedEvaluation<Animatable.T>"))));
    },
    _describeFlingGesture$1(velocity) {
      var t1, vx, vy, flingDirection, _this = this;
      if (_this._dragExtent === 0)
        return C._FlingGestureKind_0;
      t1 = velocity.pixelsPerSecond;
      vx = t1._dx;
      vy = t1._dy;
      if (_this.get$_directionIsXAxis()) {
        t1 = Math.abs(vx);
        if (t1 - Math.abs(vy) < 400 || t1 < 700)
          return C._FlingGestureKind_0;
        flingDirection = _this._extentToDirection$1(vx);
      } else {
        t1 = Math.abs(vy);
        if (t1 - Math.abs(vx) < 400 || t1 < 700)
          return C._FlingGestureKind_0;
        flingDirection = _this._extentToDirection$1(vy);
      }
      if (flingDirection === _this._extentToDirection$1(_this._dragExtent))
        return C._FlingGestureKind_1;
      return C._FlingGestureKind_2;
    },
    _dismissible$_handleDragEnd$1(details) {
      var t1, t2, flingVelocity, _this = this;
      if (!_this._dragUnderway) {
        t1 = _this._moveController._ticker;
        t1 = t1 != null && t1._ticker$_future != null;
      } else
        t1 = true;
      if (t1) {
        t1 = _this._moveController._ticker;
        t1 = t1 != null && t1._ticker$_future != null;
      } else
        t1 = true;
      if (t1)
        return;
      _this._dragUnderway = false;
      t1 = _this._moveController;
      if (t1.get$status(t1) === D.AnimationStatus_3) {
        _this._handleMoveCompleted$0();
        return;
      }
      t1 = details.velocity;
      t2 = t1.pixelsPerSecond;
      flingVelocity = _this.get$_directionIsXAxis() ? t2._dx : t2._dy;
      switch (_this._describeFlingGesture$1(t1).index) {
        case 1:
          _this._widget.toString;
          C.Map_empty6.$index(0, _this._extentToDirection$1(_this._dragExtent));
          _this._dragExtent = J.get$sign$in(flingVelocity);
          _this._moveController.fling$1$velocity(Math.abs(flingVelocity) * 0.0033333333333333335);
          break;
        case 2:
          _this._dragExtent = J.get$sign$in(flingVelocity);
          _this._moveController.fling$1$velocity(-Math.abs(flingVelocity) * 0.0033333333333333335);
          break;
        case 0:
          t1 = _this._moveController;
          if (t1.get$status(t1) !== D.AnimationStatus_0) {
            t1 = _this._moveController.__AnimationController__value_A;
            t1 === $ && A.throwLateFieldNI("_value");
            _this._widget.toString;
            C.Map_empty6.$index(0, _this._extentToDirection$1(_this._dragExtent));
            t2 = _this._moveController;
            if (t1 > 0.4)
              t2.forward$0(0);
            else
              t2.reverse$0(0);
          }
          break;
      }
    },
    _handleDismissStatusChanged$1($status) {
      return this._handleDismissStatusChanged$body$_DismissibleState(type$.AnimationStatus._as($status));
    },
    _handleDismissStatusChanged$body$_DismissibleState($status) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$self = this;
      var $async$_handleDismissStatusChanged$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = $status === D.AnimationStatus_3 && !$async$self._dragUnderway ? 2 : 3;
              break;
            case 2:
              // then
              $async$goto = 4;
              return A._asyncAwait($async$self._handleMoveCompleted$0(), $async$_handleDismissStatusChanged$1);
            case 4:
              // returning from await.
            case 3:
              // join
              if ($async$self._framework$_element != null)
                $async$self.updateKeepAlive$0();
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$_handleDismissStatusChanged$1, $async$completer);
    },
    _handleMoveCompleted$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$self = this, result;
      var $async$_handleMoveCompleted$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$self._widget.toString;
              C.Map_empty6.$index(0, $async$self._extentToDirection$1($async$self._dragExtent));
              $async$goto = 2;
              return A._asyncAwait($async$self._confirmStartResizeAnimation$0(), $async$_handleMoveCompleted$0);
            case 2:
              // returning from await.
              result = $async$result;
              if ($async$self._framework$_element != null)
                if (result)
                  $async$self._startResizeAnimation$0();
                else
                  $async$self._moveController.reverse$0(0);
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$_handleMoveCompleted$0, $async$completer);
    },
    _confirmStartResizeAnimation$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.bool),
        $async$returnValue, $async$self = this;
      var $async$_confirmStartResizeAnimation$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$self._widget.toString;
              $async$returnValue = true;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$_confirmStartResizeAnimation$0, $async$completer);
    },
    _startResizeAnimation$0() {
      var direction, _this = this;
      _this._widget.toString;
      direction = _this._extentToDirection$1(_this._dragExtent);
      _this._widget.onDismissed.call$1(direction);
    },
    build$1(context) {
      var t1, t2, t3, t4, $content, t5, t6, _this = this, _null = null;
      _this.super$AutomaticKeepAliveClientMixin$build(context);
      t1 = _this._widget;
      t1.toString;
      t2 = _this._resizeAnimation;
      if (t2 != null) {
        t1 = _this.get$_directionIsXAxis() ? D.Axis_1 : D.Axis_0;
        t3 = _this._sizePriorToCollapse;
        t4 = t3._dx;
        return A.SizeTransition$(t1, A.SizedBox$(_null, t3._dy, t4), t2);
      }
      t2 = _this.___DismissibleState__moveAnimation_A;
      t2 === $ && A.throwLateFieldNI("_moveAnimation");
      $content = A.SlideTransition$(new A.KeyedSubtree(t1.child, _this._contentKey), t2, _null, true);
      if (t1.direction === C.DismissDirection_6)
        return $content;
      t1 = _this.get$_directionIsXAxis() ? _this.get$_dismissible$_handleDragStart() : _null;
      t2 = _this.get$_directionIsXAxis() ? _this.get$_dismissible$_handleDragUpdate() : _null;
      t3 = _this.get$_directionIsXAxis() ? _this.get$_dismissible$_handleDragEnd() : _null;
      t4 = _this.get$_directionIsXAxis() ? _null : _this.get$_dismissible$_handleDragStart();
      t5 = _this.get$_directionIsXAxis() ? _null : _this.get$_dismissible$_handleDragUpdate();
      t6 = _this.get$_directionIsXAxis() ? _null : _this.get$_dismissible$_handleDragEnd();
      _this._widget.toString;
      return A.GestureDetector$(D.HitTestBehavior_1, $content, D.DragStartBehavior_1, false, _null, _null, _null, _null, t3, t1, t2, _null, _null, _null, _null, _null, _null, _null, _null, _null, t6, t4, t5);
    },
    set$___DismissibleState__moveAnimation_A(___DismissibleState__moveAnimation_A) {
      this.___DismissibleState__moveAnimation_A = type$.Animation_Offset._as(___DismissibleState__moveAnimation_A);
    },
    $isTickerProvider: 1
  };
  B.__DismissibleState_State_TickerProviderStateMixin.prototype = {
    activate$0() {
      this.super$State$activate();
      this._updateTickerModeNotifier$0();
      this._updateTickers$0();
    },
    dispose$0() {
      var _this = this,
        t1 = _this.TickerProviderStateMixin__tickerModeNotifier;
      if (t1 != null)
        t1.removeListener$1(0, _this.get$_updateTickers());
      _this.set$_tickerModeNotifier(null);
      _this.super$State$dispose();
    }
  };
  B.__DismissibleState_State_TickerProviderStateMixin_AutomaticKeepAliveClientMixin.prototype = {
    initState$0() {
      this.super$State$initState();
      if (this.get$wantKeepAlive())
        this._ensureKeepAlive$0();
    },
    deactivate$0() {
      var t1 = this.AutomaticKeepAliveClientMixin__keepAliveHandle;
      if (t1 != null) {
        t1.notifyListeners$0();
        t1.super$ChangeNotifier$dispose();
        this.AutomaticKeepAliveClientMixin__keepAliveHandle = null;
      }
      this.super$State$deactivate();
    }
  };
  var typesOffset = hunkHelpers.updateTypes(["~(AnimationStatus)", "~(DismissDirection)", "~(DragStartDetails)", "~(DragUpdateDetails)", "~()", "~(DragEndDetails)", "Future<~>(AnimationStatus)"]);
  B._SnackBarState_build_closure0.prototype = {
    call$0() {
      var t1 = this.context.dependOnInheritedWidgetOfExactType$1$0(type$._ScaffoldMessengerScope);
      t1.toString;
      t1._scaffoldMessengerState.removeCurrentSnackBar$1$reason(C.SnackBarClosedReason_1);
    },
    $signature: 0
  };
  B._SnackBarState_build_closure.prototype = {
    call$1(direction) {
      var t1 = this.context.dependOnInheritedWidgetOfExactType$1$0(type$._ScaffoldMessengerScope);
      t1.toString;
      t1._scaffoldMessengerState.removeCurrentSnackBar$1$reason(C.SnackBarClosedReason_2);
    },
    $signature: typesOffset + 1
  };
  B._SnackBarState_build_closure1.prototype = {
    call$2(context, child) {
      var t1;
      type$.BuildContext._as(context);
      type$.nullable_Widget._as(child);
      t1 = this.heightAnimation;
      return new A.Align(D.AlignmentDirectional_m1_m1, null, t1.get$value(t1), child, null);
    },
    $signature: 489
  };
  B._DismissibleState__handleDragStart_closure.prototype = {
    call$0() {
      this.$this._updateMoveAnimation$0();
    },
    $signature: 0
  };
  B._DismissibleState__handleDragUpdate_closure.prototype = {
    call$0() {
      this.$this._updateMoveAnimation$0();
    },
    $signature: 0
  };
  (function aliases() {
    var _ = B.__DismissibleState_State_TickerProviderStateMixin.prototype;
    _.super$__DismissibleState_State_TickerProviderStateMixin$dispose = _.dispose$0;
    _ = B.__DismissibleState_State_TickerProviderStateMixin_AutomaticKeepAliveClientMixin.prototype;
    _.super$__DismissibleState_State_TickerProviderStateMixin_AutomaticKeepAliveClientMixin$initState = _.initState$0;
  })();
  (function installTearOffs() {
    var _instance_1_u = hunkHelpers._instance_1u,
      _instance_0_u = hunkHelpers._instance_0u;
    _instance_1_u(B._SnackBarState.prototype, "get$_onAnimationStatusChanged", "_onAnimationStatusChanged$1", 0);
    var _;
    _instance_1_u(_ = B._DismissibleState.prototype, "get$_dismissible$_handleDragStart", "_dismissible$_handleDragStart$1", 2);
    _instance_1_u(_, "get$_dismissible$_handleDragUpdate", "_dismissible$_handleDragUpdate$1", 3);
    _instance_0_u(_, "get$_handleDismissUpdateValueChanged", "_handleDismissUpdateValueChanged$0", 4);
    _instance_1_u(_, "get$_dismissible$_handleDragEnd", "_dismissible$_handleDragEnd$1", 5);
    _instance_1_u(_, "get$_handleDismissStatusChanged", "_handleDismissStatusChanged$1", 6);
  })();
  (function inheritance() {
    var _mixinHard = hunkHelpers.mixinHard,
      _inheritMany = hunkHelpers.inheritMany,
      _inherit = hunkHelpers.inherit;
    _inheritMany(A.StatefulWidget, [B.SnackBar, B.Dismissible]);
    _inheritMany(A.State, [B._SnackBarState, B.__DismissibleState_State_TickerProviderStateMixin]);
    _inheritMany(A.Closure0Args, [B._SnackBarState_build_closure0, B._DismissibleState__handleDragStart_closure, B._DismissibleState__handleDragUpdate_closure]);
    _inherit(B._SnackBarState_build_closure, A.Closure);
    _inherit(B._SnackBarState_build_closure1, A.Closure2Args);
    _inherit(B._SnackbarDefaultsM2, A.SnackBarThemeData);
    _inheritMany(A._Enum, [B.DismissDirection, B._FlingGestureKind]);
    _inherit(B.__DismissibleState_State_TickerProviderStateMixin_AutomaticKeepAliveClientMixin, B.__DismissibleState_State_TickerProviderStateMixin);
    _inherit(B._DismissibleState, B.__DismissibleState_State_TickerProviderStateMixin_AutomaticKeepAliveClientMixin);
    _mixinHard(B.__DismissibleState_State_TickerProviderStateMixin, A.TickerProviderStateMixin);
    _mixinHard(B.__DismissibleState_State_TickerProviderStateMixin_AutomaticKeepAliveClientMixin, A.AutomaticKeepAliveClientMixin);
  })();
  A._Universe_addRules(init.typeUniverse, JSON.parse('{"SnackBar":{"StatefulWidget":[],"Widget":[],"DiagnosticableTree":[]},"_SnackBarState":{"State":["SnackBar"],"State.T":"SnackBar"},"_SnackbarDefaultsM2":{"SnackBarThemeData":[]},"DismissDirection":{"Enum":[]},"Dismissible":{"StatefulWidget":[],"Widget":[],"DiagnosticableTree":[]},"_FlingGestureKind":{"Enum":[]},"_DismissibleState":{"TickerProviderStateMixin":["Dismissible"],"State":["Dismissible"],"TickerProvider":[],"State.T":"Dismissible"}}'));
  var type$ = (function rtii() {
    var findType = A.findType;
    return {
      Animatable_Offset: findType("Animatable<Offset>"),
      AnimationStatus: findType("AnimationStatus"),
      Animation_Offset: findType("Animation<Offset>"),
      Animation_double: findType("Animation<double>"),
      BuildContext: findType("BuildContext"),
      Directionality: findType("Directionality"),
      JSArray_Widget: findType("JSArray<Widget>"),
      LabeledGlobalKey_State_StatefulWidget: findType("LabeledGlobalKey<State<StatefulWidget>>"),
      MediaQuery: findType("MediaQuery"),
      SnackBar: findType("SnackBar"),
      Tween_Offset: findType("Tween<Offset>"),
      _ScaffoldMessengerScope: findType("_ScaffoldMessengerScope"),
      bool: findType("bool"),
      nullable_Widget: findType("Widget?"),
      void: findType("~"),
      void_Function: findType("~()"),
      void_Function_AnimationStatus: findType("~(AnimationStatus)")
    };
  })();
  (function constants() {
    var makeConstList = hunkHelpers.makeConstList;
    C.Cubic_gWH = new A.Cubic(0.77, 0, 0.175, 1);
    C.DismissDirection_1 = new B.DismissDirection(1, "horizontal");
    C.DismissDirection_2 = new B.DismissDirection(2, "endToStart");
    C.DismissDirection_3 = new B.DismissDirection(3, "startToEnd");
    C.DismissDirection_4 = new B.DismissDirection(4, "up");
    C.DismissDirection_5 = new B.DismissDirection(5, "down");
    C.DismissDirection_6 = new B.DismissDirection(6, "none");
    C.Duration_4000000 = new A.Duration(4000000);
    C.EdgeInsets_0_0_0_14 = new A.EdgeInsets(0, 0, 0, 14);
    C.EdgeInsets_0_14_0_14 = new A.EdgeInsets(0, 14, 0, 14);
    C.EdgeInsets_15_5_15_10 = new A.EdgeInsets(15, 5, 15, 10);
    C.Cubic_MLw = new A.Cubic(0.6, 0.04, 0.98, 0.335);
    C.Interval_0Q9 = new A.Interval(0.4, 0.6, C.Cubic_MLw);
    C.Interval_8qt = new A.Interval(0.72, 1, D.Cubic_ifx);
    C.Interval_jzi = new A.Interval(0.4, 1, D.C__Linear);
    C.List_empty27 = A._setArrayType(makeConstList([]), A.findType("JSArray<DismissDirection>"));
    C.Map_empty6 = new A.ConstantStringMap(0, {}, C.List_empty27, A.findType("ConstantStringMap<DismissDirection,double>"));
    C.SnackBarClosedReason_1 = new A.SnackBarClosedReason(1, "dismiss");
    C.SnackBarClosedReason_2 = new A.SnackBarClosedReason(2, "swipe");
    C.ValueKey_dismissible = new A.ValueKey("dismissible", A.findType("ValueKey<String>"));
    C._FlingGestureKind_0 = new B._FlingGestureKind(0, "none");
    C._FlingGestureKind_1 = new B._FlingGestureKind(1, "forward");
    C._FlingGestureKind_2 = new B._FlingGestureKind(2, "reverse");
  })();
};

$__dart_deferred_initializers__["LlFZlDJoJU3Idb75pLH0VkzNRms="] = $__dart_deferred_initializers__.current
