// Generated by dart2js (NullSafetyMode.sound, csp, deferred-serialization, intern-composite-values), the Dart to JavaScript compiler version: 2.19.6.
self.$__dart_deferred_initializers__ = self.$__dart_deferred_initializers__ || Object.create(null);
$__dart_deferred_initializers__.current = function(hunkHelpers, init, holdersList, $) {
  var B = {SelectionRegistrant: function SelectionRegistrant() {
    }, SelectionEvent: function SelectionEvent() {
    }, ClearSelectionEvent: function ClearSelectionEvent(t0) {
      this.type = t0;
    }, SelectionEdgeUpdateEvent: function SelectionEdgeUpdateEvent(t0, t1) {
      this.globalPosition = t0;
      this.type = t1;
    }, RevealedOffset: function RevealedOffset(t0, t1) {
      this.offset = t0;
      this.rect = t1;
    },
    Scrollable$(axisDirection, clipBehavior, controller, dragStartBehavior, excludeFromSemantics, key, physics, restorationId, scrollBehavior, semanticChildCount, viewportBuilder) {
      return new B.Scrollable(axisDirection, controller, physics, viewportBuilder, excludeFromSemantics, semanticChildCount, dragStartBehavior, restorationId, scrollBehavior, clipBehavior, key);
    },
    _getDeltaToScrollOrigin(scrollableState) {
      var t1;
      switch (scrollableState._widget.axisDirection.index) {
        case 2:
          t1 = scrollableState._scrollable$_position._pixels;
          t1.toString;
          return new A.Offset(0, t1);
        case 0:
          t1 = scrollableState._scrollable$_position._pixels;
          t1.toString;
          return new A.Offset(0, -t1);
        case 3:
          t1 = scrollableState._scrollable$_position._pixels;
          t1.toString;
          return new A.Offset(-t1, 0);
        case 1:
          t1 = scrollableState._scrollable$_position._pixels;
          t1.toString;
          return new A.Offset(t1, 0);
      }
    },
    _ScrollableState_State_TickerProviderStateMixin_RestorationMixin_dispose_closure: function _ScrollableState_State_TickerProviderStateMixin_RestorationMixin_dispose_closure() {
    },
    Scrollable: function Scrollable(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10) {
      var _ = this;
      _.axisDirection = t0;
      _.controller = t1;
      _.physics = t2;
      _.viewportBuilder = t3;
      _.excludeFromSemantics = t4;
      _.semanticChildCount = t5;
      _.dragStartBehavior = t6;
      _.restorationId = t7;
      _.scrollBehavior = t8;
      _.clipBehavior = t9;
      _.key = t10;
    },
    _ScrollableScope: function _ScrollableScope(t0, t1, t2, t3) {
      var _ = this;
      _.scrollable = t0;
      _.position = t1;
      _.child = t2;
      _.key = t3;
    },
    ScrollableState: function ScrollableState(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12) {
      var _ = this;
      _._scrollable$_position = null;
      _._persistedScrollOffset = t0;
      _.__ScrollableState__configuration_A = $;
      _._mediaQueryData = _._fallbackScrollController = _._physics = null;
      _._scrollSemanticsKey = t1;
      _._gestureDetectorKey = t2;
      _._ignorePointerKey = t3;
      _._gestureRecognizers = t4;
      _._shouldIgnorePointer = false;
      _._hold = _._drag = _._scrollable$_lastAxisDirection = _._lastCanDrag = null;
      _.RestorationMixin__bucket = t5;
      _.RestorationMixin__properties = t6;
      _.RestorationMixin__debugPropertiesWaitingForReregistration = t7;
      _.RestorationMixin__firstRestorePending = t8;
      _.RestorationMixin__currentParent = t9;
      _.TickerProviderStateMixin__tickers = t10;
      _.TickerProviderStateMixin__tickerModeNotifier = t11;
      _._widget = null;
      _._debugLifecycleState = t12;
      _._framework$_element = null;
    },
    ScrollableState_setCanDrag_closure: function ScrollableState_setCanDrag_closure(t0) {
      this.$this = t0;
    },
    ScrollableState_setCanDrag_closure0: function ScrollableState_setCanDrag_closure0(t0) {
      this.$this = t0;
    },
    ScrollableState_setCanDrag_closure1: function ScrollableState_setCanDrag_closure1(t0) {
      this.$this = t0;
    },
    ScrollableState_setCanDrag_closure2: function ScrollableState_setCanDrag_closure2(t0) {
      this.$this = t0;
    },
    _ScrollableSelectionHandler: function _ScrollableSelectionHandler(t0, t1, t2, t3, t4) {
      var _ = this;
      _.state = t0;
      _.position = t1;
      _.child = t2;
      _.registrar = t3;
      _.key = t4;
    },
    _ScrollableSelectionHandlerState: function _ScrollableSelectionHandlerState(t0) {
      var _ = this;
      _.___ScrollableSelectionHandlerState__selectionDelegate_A = $;
      _._widget = null;
      _._debugLifecycleState = t0;
      _._framework$_element = null;
    },
    EdgeDraggingAutoScroller: function EdgeDraggingAutoScroller(t0, t1) {
      var _ = this;
      _.scrollable = t0;
      _.velocityScalar = t1;
      _.__EdgeDraggingAutoScroller__dragTargetRelatedToScrollOrigin_A = $;
      _._scrolling = false;
    },
    _ScrollableSelectionContainerDelegate: function _ScrollableSelectionContainerDelegate(t0, t1, t2, t3, t4, t5, t6, t7, t8) {
      var _ = this;
      _.state = t0;
      _._autoScroller = t1;
      _._scheduledLayoutChange = false;
      _._currentDragEndRelatedToOrigin = _._currentDragStartRelatedToOrigin = null;
      _._selectionStartsInScrollable = false;
      _._scrollable$_position = t2;
      _._selectableStartEdgeUpdateRecords = t3;
      _._selectableEndEdgeUpdateRecords = t4;
      _.selectables = t5;
      _.currentSelectionStartIndex = _.currentSelectionEndIndex = -1;
      _._endHandleLayerOwner = _._endHandleLayer = _._startHandleLayerOwner = _._startHandleLayer = null;
      _._selectionInProgress = _._scheduledSelectableUpdate = _._isHandlingSelectionEvent = false;
      _._additions = t6;
      _._extendSelectionInProgress = false;
      _._selectionGeometry = t7;
      _.ChangeNotifier__count = 0;
      _.ChangeNotifier__listeners = t8;
      _.ChangeNotifier__reentrantlyRemovedListeners = _.ChangeNotifier__notificationCallStackDepth = 0;
      _.ChangeNotifier__creationDispatched = _.ChangeNotifier__debugDisposed = false;
      _._selectionContainerContext = null;
    },
    _ScrollableSelectionContainerDelegate__scheduleLayoutChange_closure: function _ScrollableSelectionContainerDelegate__scheduleLayoutChange_closure(t0) {
      this.$this = t0;
    },
    _ScrollableSelectionContainerDelegate_didChangeSelectables_closure: function _ScrollableSelectionContainerDelegate_didChangeSelectables_closure(t0) {
      this.selectableSet = t0;
    },
    _ScrollableSelectionContainerDelegate_didChangeSelectables_closure0: function _ScrollableSelectionContainerDelegate_didChangeSelectables_closure0(t0) {
      this.selectableSet = t0;
    },
    ScrollableDetails: function ScrollableDetails(t0, t1, t2) {
      this.direction = t0;
      this.controller = t1;
      this.clipBehavior = t2;
    },
    _ScrollSemantics: function _ScrollSemantics(t0, t1, t2, t3, t4) {
      var _ = this;
      _.position = t0;
      _.allowImplicitScrolling = t1;
      _.semanticChildCount = t2;
      _.child = t3;
      _.key = t4;
    },
    _RenderScrollSemantics: function _RenderScrollSemantics(t0, t1, t2, t3, t4) {
      var _ = this;
      _._scrollable$_position = t0;
      _._allowImplicitScrolling = t1;
      _._semanticChildCount = t2;
      _._innerNode = null;
      _.RenderObjectWithChildMixin__child = t3;
      _._cachedDryLayoutSizes = _._cachedIntrinsicDimensions = null;
      _._computingThisDryLayout = false;
      _._cachedBaselines = _._size = null;
      _._debugActivePointers = 0;
      _._debugDisposed = false;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _.__RenderObject__wasRepaintBoundary_A = $;
      _._layerHandle = t4;
      _._needsCompositingBitsUpdate = false;
      _.__RenderObject__needsCompositing_A = $;
      _._needsPaint = true;
      _._needsCompositedLayerUpdate = false;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    _RestorableScrollOffset: function _RestorableScrollOffset(t0) {
      var _ = this;
      _._restoration_properties$_value = null;
      _._restoration0$_disposed = false;
      _._restoration0$_owner = _._restoration0$_restorationId = null;
      _.ChangeNotifier__count = 0;
      _.ChangeNotifier__listeners = t0;
      _.ChangeNotifier__reentrantlyRemovedListeners = _.ChangeNotifier__notificationCallStackDepth = 0;
      _.ChangeNotifier__creationDispatched = _.ChangeNotifier__debugDisposed = false;
    },
    _ScrollableState_State_TickerProviderStateMixin: function _ScrollableState_State_TickerProviderStateMixin() {
    },
    _ScrollableState_State_TickerProviderStateMixin_RestorationMixin: function _ScrollableState_State_TickerProviderStateMixin_RestorationMixin() {
    },
    MultiSelectableSelectionContainerDelegate__compareVertically(a, b) {
      var t4,
        t1 = a.top,
        t2 = b.top,
        t3 = t1 - t2;
      if (!(t3 < 1e-10 && a.bottom - b.bottom > -1e-10))
        t4 = t2 - t1 < 1e-10 && b.bottom - a.bottom > -1e-10;
      else
        t4 = true;
      if (t4)
        return 0;
      if (Math.abs(t3) > 1e-10)
        return t1 > t2 ? 1 : -1;
      return a.bottom > b.bottom ? 1 : -1;
    },
    MultiSelectableSelectionContainerDelegate__compareHorizontally(a, b) {
      var t1 = a.left,
        t2 = b.left,
        t3 = t1 - t2;
      if (t3 < 1e-10 && a.right - b.right > -1e-10)
        return -1;
      if (t2 - t1 < 1e-10 && b.right - a.right > -1e-10)
        return 1;
      if (Math.abs(t3) > 1e-10)
        return t1 > t2 ? 1 : -1;
      return a.right > b.right ? 1 : -1;
    },
    MultiSelectableSelectionContainerDelegate: function MultiSelectableSelectionContainerDelegate() {
    },
    MultiSelectableSelectionContainerDelegate__scheduleSelectableUpdate_closure: function MultiSelectableSelectionContainerDelegate__scheduleSelectableUpdate_closure(t0) {
      this.$this = t0;
    },
    MultiSelectableSelectionContainerDelegate_handleSelectWord_closure: function MultiSelectableSelectionContainerDelegate_handleSelectWord_closure(t0, t1) {
      this.$this = t0;
      this.index = t1;
    },
    MultiSelectableSelectionContainerDelegate_handleSelectWord_closure0: function MultiSelectableSelectionContainerDelegate_handleSelectWord_closure0(t0) {
      this.$this = t0;
    },
    _MultiSelectableSelectionContainerDelegate_SelectionContainerDelegate_ChangeNotifier: function _MultiSelectableSelectionContainerDelegate_SelectionContainerDelegate_ChangeNotifier() {
    },
    SelectionRegistrarScope$(child, registrar) {
      return new B.SelectionRegistrarScope(registrar, child, null);
    },
    SelectionContainer: function SelectionContainer(t0, t1, t2, t3) {
      var _ = this;
      _.registrar = t0;
      _.child = t1;
      _.delegate = t2;
      _.key = t3;
    },
    _SelectionContainerState: function _SelectionContainerState(t0, t1, t2, t3) {
      var _ = this;
      _._selection_container$_listeners = t0;
      _.SelectionRegistrant__registrar = t1;
      _.SelectionRegistrant__subscribedToSelectionRegistrar = t2;
      _._widget = null;
      _._debugLifecycleState = t3;
      _._framework$_element = null;
    },
    SelectionRegistrarScope: function SelectionRegistrarScope(t0, t1, t2) {
      this.registrar = t0;
      this.child = t1;
      this.key = t2;
    },
    SelectionContainerDelegate: function SelectionContainerDelegate() {
    },
    __SelectionContainerState_State_Selectable: function __SelectionContainerState_State_Selectable() {
    },
    __SelectionContainerState_State_Selectable_SelectionRegistrant: function __SelectionContainerState_State_Selectable_SelectionRegistrant() {
    }
  },
  A, C, J, D;
  B = hunkHelpers.updateHolder(holdersList[53], B);
  A = holdersList[0];
  C = holdersList[2];
  J = holdersList[1];
  D = holdersList[83];
  B.SelectionRegistrant.prototype = {
    set$registrar(value) {
      var _this = this,
        t1 = _this.SelectionRegistrant__registrar;
      if (value == t1)
        return;
      if (value == null)
        _this.removeListener$1(0, _this.get$_selection$_updateSelectionRegistrarSubscription());
      else if (t1 == null)
        _this.addListener$1(0, _this.get$_selection$_updateSelectionRegistrarSubscription());
      _this._selection$_removeSelectionRegistrarSubscription$0();
      _this.SelectionRegistrant__registrar = value;
      _this._selection$_updateSelectionRegistrarSubscription$0();
    },
    _selection$_updateSelectionRegistrarSubscription$0() {
      var _this = this;
      if (_this.SelectionRegistrant__registrar == null) {
        _this.SelectionRegistrant__subscribedToSelectionRegistrar = false;
        return;
      }
      if (_this.SelectionRegistrant__subscribedToSelectionRegistrar && !_this.get$value(_this).hasContent) {
        _this.SelectionRegistrant__registrar.remove$1(0, _this);
        _this.SelectionRegistrant__subscribedToSelectionRegistrar = false;
      } else if (!_this.SelectionRegistrant__subscribedToSelectionRegistrar && _this.get$value(_this).hasContent) {
        _this.SelectionRegistrant__registrar.add$1(0, _this);
        _this.SelectionRegistrant__subscribedToSelectionRegistrar = true;
      }
    },
    _selection$_removeSelectionRegistrarSubscription$0() {
      var _this = this;
      if (_this.SelectionRegistrant__subscribedToSelectionRegistrar) {
        _this.SelectionRegistrant__registrar.remove$1(0, _this);
        _this.SelectionRegistrant__subscribedToSelectionRegistrar = false;
      }
    }
  };
  B.SelectionEvent.prototype = {};
  B.ClearSelectionEvent.prototype = {};
  B.SelectionEdgeUpdateEvent.prototype = {};
  B.RevealedOffset.prototype = {
    toString$0(_) {
      return "RevealedOffset(offset: " + A.S(this.offset) + ", rect: " + this.rect.toString$0(0) + ")";
    }
  };
  B.Scrollable.prototype = {
    createState$0() {
      var _null = null,
        t1 = type$.LabeledGlobalKey_State_StatefulWidget;
      return new B.ScrollableState(new B._RestorableScrollOffset($.$get$ChangeNotifier__emptyListeners()), new A.LabeledGlobalKey(_null, t1), new A.LabeledGlobalKey(_null, type$.LabeledGlobalKey_RawGestureDetectorState), new A.LabeledGlobalKey(_null, t1), C.Map_empty5, _null, A.LinkedHashMap_LinkedHashMap$_empty(type$.RestorableProperty_nullable_Object, type$.void_Function), _null, true, _null, _null, _null, C._StateLifecycle_0);
    },
    viewportBuilder$2(arg0, arg1) {
      return this.viewportBuilder.call$2(arg0, arg1);
    }
  };
  B._ScrollableScope.prototype = {
    updateShouldNotify$1(old) {
      return this.position !== type$._ScrollableScope._as(old).position;
    }
  };
  B.ScrollableState.prototype = {
    get$position(_) {
      var t1 = this._scrollable$_position;
      t1.toString;
      return t1;
    },
    get$axisDirection() {
      return this._widget.axisDirection;
    },
    get$_effectiveScrollController() {
      var t1 = this._widget.controller;
      if (t1 == null) {
        t1 = this._fallbackScrollController;
        t1.toString;
      }
      return t1;
    },
    _updatePosition$0() {
      var t2, t3, oldPosition, _this = this,
        t1 = _this._widget.scrollBehavior;
      if (t1 == null) {
        t1 = _this._framework$_element;
        t1.toString;
        t1 = A.ScrollConfiguration_of(t1);
      }
      _this.__ScrollableState__configuration_A = t1;
      t2 = _this._framework$_element;
      t2.toString;
      t2 = t1.getScrollPhysics$1(t2);
      _this._physics = t2;
      t1 = _this._widget;
      t3 = t1.physics;
      if (t3 != null)
        _this._physics = t3.applyTo$1(t2);
      else {
        t1 = t1.scrollBehavior;
        if (t1 != null) {
          t2 = _this._framework$_element;
          t2.toString;
          _this._physics = t1.getScrollPhysics$1(t2).applyTo$1(_this._physics);
        }
      }
      oldPosition = _this._scrollable$_position;
      if (oldPosition != null) {
        _this.get$_effectiveScrollController().detach$1(0, oldPosition);
        A.scheduleMicrotask(oldPosition.get$dispose());
      }
      t1 = _this.get$_effectiveScrollController();
      t2 = _this._physics;
      t2.toString;
      _this._scrollable$_position = t1.createScrollPosition$3(t2, _this, oldPosition);
      t2 = _this.get$_effectiveScrollController();
      t1 = _this._scrollable$_position;
      t1.toString;
      t2.attach$1(t1);
    },
    restoreState$2(oldBucket, initialRestore) {
      var t2, t3, t4,
        t1 = this._persistedScrollOffset;
      this.registerForRestoration$2(t1, "offset");
      t2 = t1._restoration_properties$_value;
      t3 = t2 == null;
      if ((t3 ? A._instanceType(t1)._eval$1("RestorableValue.T")._as(t2) : t2) != null) {
        t4 = this._scrollable$_position;
        t4.toString;
        t1 = t3 ? A._instanceType(t1)._eval$1("RestorableValue.T")._as(t2) : t2;
        t1.toString;
        t4.restoreOffset$2$initialRestore(t1, initialRestore);
      }
    },
    saveOffset$1(offset) {
      var t1;
      this._persistedScrollOffset.set$value(0, offset);
      t1 = $.ServicesBinding__instance.ServicesBinding___ServicesBinding__restorationManager_A;
      t1 === $ && A.throwLateFieldNI("_restorationManager");
      t1.flushData$0();
    },
    initState$0() {
      if (this._widget.controller == null)
        this._fallbackScrollController = A.ScrollController$(0);
      this.super$State$initState();
    },
    didChangeDependencies$0() {
      var _this = this,
        t1 = _this._framework$_element;
      t1.toString;
      _this._mediaQueryData = A.MediaQuery_maybeOf(t1);
      _this._updatePosition$0();
      _this.super$_ScrollableState_State_TickerProviderStateMixin_RestorationMixin$didChangeDependencies();
    },
    _shouldUpdatePosition$1(oldWidget) {
      var t2, oldPhysics, t3, _this = this, _null = null,
        t1 = _this._widget,
        newPhysics = t1.physics;
      if (newPhysics == null) {
        t1 = t1.scrollBehavior;
        if (t1 == null)
          newPhysics = _null;
        else {
          t2 = _this._framework$_element;
          t2.toString;
          t2 = t1.getScrollPhysics$1(t2);
          newPhysics = t2;
        }
      }
      oldPhysics = oldWidget.physics;
      if (oldPhysics == null) {
        t1 = oldWidget.scrollBehavior;
        if (t1 == null)
          oldPhysics = _null;
        else {
          t2 = _this._framework$_element;
          t2.toString;
          t2 = t1.getScrollPhysics$1(t2);
          oldPhysics = t2;
        }
      }
      do {
        t1 = newPhysics == null;
        t2 = t1 ? _null : A.getRuntimeType(newPhysics);
        t3 = oldPhysics == null;
        if (t2 != (t3 ? _null : A.getRuntimeType(oldPhysics)))
          return true;
        newPhysics = t1 ? _null : newPhysics.parent;
        oldPhysics = t3 ? _null : oldPhysics.parent;
      } while (newPhysics != null || oldPhysics != null);
      t1 = _this._widget.controller;
      t1 = t1 == null ? _null : A.getRuntimeType(t1);
      t2 = oldWidget.controller;
      return t1 != (t2 == null ? _null : A.getRuntimeType(t2));
    },
    didUpdateWidget$1(oldWidget) {
      var t1, t2, _this = this;
      type$.Scrollable._as(oldWidget);
      _this.super$_ScrollableState_State_TickerProviderStateMixin_RestorationMixin$didUpdateWidget(oldWidget);
      t1 = oldWidget.controller;
      if (_this._widget.controller != t1) {
        if (t1 == null) {
          t1 = _this._fallbackScrollController;
          t1.toString;
          t2 = _this._scrollable$_position;
          t2.toString;
          t1.detach$1(0, t2);
          _this._fallbackScrollController.dispose$0();
          _this._fallbackScrollController = null;
        } else {
          t2 = _this._scrollable$_position;
          t2.toString;
          t1.detach$1(0, t2);
          if (_this._widget.controller == null)
            _this._fallbackScrollController = A.ScrollController$(0);
        }
        t1 = _this.get$_effectiveScrollController();
        t2 = _this._scrollable$_position;
        t2.toString;
        t1.attach$1(t2);
      }
      if (_this._shouldUpdatePosition$1(oldWidget))
        _this._updatePosition$0();
    },
    dispose$0() {
      var t2, _this = this,
        t1 = _this._widget.controller;
      if (t1 != null) {
        t2 = _this._scrollable$_position;
        t2.toString;
        t1.detach$1(0, t2);
      } else {
        t1 = _this._fallbackScrollController;
        if (t1 != null) {
          t2 = _this._scrollable$_position;
          t2.toString;
          t1.detach$1(0, t2);
        }
        t1 = _this._fallbackScrollController;
        if (t1 != null)
          t1.dispose$0();
      }
      _this._scrollable$_position.dispose$0();
      _this._persistedScrollOffset.dispose$0();
      _this.super$_ScrollableState_State_TickerProviderStateMixin_RestorationMixin$dispose();
    },
    setSemanticsActions$1(actions) {
      var t1;
      type$.Set_SemanticsAction._as(actions);
      t1 = this._gestureDetectorKey;
      if (t1.get$currentState() != null)
        t1.get$currentState().replaceSemanticsActions$1(actions);
    },
    setCanDrag$1(value) {
      var t1, t2, _this = this;
      if (value === _this._lastCanDrag)
        t1 = !value || A.axisDirectionToAxis(_this._widget.axisDirection) === _this._scrollable$_lastAxisDirection;
      else
        t1 = false;
      if (t1)
        return;
      if (!value) {
        _this.set$_gestureRecognizers(C.Map_empty5);
        _this._scrollable$_handleDragCancel$0();
      } else {
        switch (A.axisDirectionToAxis(_this._widget.axisDirection).index) {
          case 1:
            _this.set$_gestureRecognizers(A.LinkedHashMap_LinkedHashMap$_literal([C.Type_mLh, new A.GestureRecognizerFactoryWithHandlers(new B.ScrollableState_setCanDrag_closure(_this), new B.ScrollableState_setCanDrag_closure0(_this), type$.GestureRecognizerFactoryWithHandlers_VerticalDragGestureRecognizer)], type$.Type, type$.GestureRecognizerFactory_GestureRecognizer));
            break;
          case 0:
            _this.set$_gestureRecognizers(A.LinkedHashMap_LinkedHashMap$_literal([C.Type_Vq1, new A.GestureRecognizerFactoryWithHandlers(new B.ScrollableState_setCanDrag_closure1(_this), new B.ScrollableState_setCanDrag_closure2(_this), type$.GestureRecognizerFactoryWithHandlers_HorizontalDragGestureRecognizer)], type$.Type, type$.GestureRecognizerFactory_GestureRecognizer));
            break;
        }
        value = true;
      }
      _this._lastCanDrag = value;
      _this._scrollable$_lastAxisDirection = A.axisDirectionToAxis(_this._widget.axisDirection);
      t1 = _this._gestureDetectorKey;
      if (t1.get$currentState() != null) {
        t1 = t1.get$currentState();
        t1.toString;
        t1._syncAll$1(type$.Map_of_Type_and_GestureRecognizerFactory_GestureRecognizer._as(_this._gestureRecognizers));
        if (!t1._widget.excludeFromSemantics) {
          t2 = t1._framework$_element.get$renderObject();
          t2.toString;
          type$.RenderSemanticsGestureHandler._as(t2);
          t1._gesture_detector$_semantics.assignSemantics$1(t2);
        }
      }
    },
    get$vsync() {
      return this;
    },
    setIgnorePointer$1(value) {
      var t1, _this = this;
      if (_this._shouldIgnorePointer === value)
        return;
      _this._shouldIgnorePointer = value;
      t1 = _this._ignorePointerKey;
      if ($.WidgetsBinding__instance.WidgetsBinding__buildOwner._globalKeyRegistry.$index(0, t1) != null) {
        t1 = $.WidgetsBinding__instance.WidgetsBinding__buildOwner._globalKeyRegistry.$index(0, t1).get$renderObject();
        t1.toString;
        type$.RenderIgnorePointer._as(t1).set$ignoring(_this._shouldIgnorePointer);
      }
    },
    get$notificationContext() {
      return $.WidgetsBinding__instance.WidgetsBinding__buildOwner._globalKeyRegistry.$index(0, this._gestureDetectorKey);
    },
    get$storageContext() {
      var t1 = this._framework$_element;
      t1.toString;
      return t1;
    },
    _handleDragDown$1(details) {
      var t2, previousVelocity, holdActivity,
        t1 = this._scrollable$_position;
      t1.toString;
      t2 = type$.void_Function._as(this.get$_disposeHold());
      previousVelocity = t1._activity.get$velocity();
      holdActivity = new A.HoldScrollActivity(t2, t1);
      t1.beginActivity$1(holdActivity);
      t1._heldPreviousVelocity = previousVelocity;
      this._hold = holdActivity;
    },
    _scrollable$_handleDragStart$1(details) {
      var t2, t3, t4, t5, drag,
        t1 = this._scrollable$_position;
      t1.toString;
      t2 = type$.void_Function._as(this.get$_disposeDrag());
      t3 = t1.physics;
      t4 = t3.carriedMomentum$1(t1._heldPreviousVelocity);
      t3 = t3.get$dragStartDistanceMotionThreshold();
      t5 = t3 == null ? null : 0;
      drag = new A.ScrollDragController(t1, t2, t4, t3, details.sourceTimeStamp, t4 !== 0, t5, details.kind, details);
      t1.beginActivity$1(new A.DragScrollActivity(drag, t1));
      this._drag = t1._currentDrag = drag;
    },
    _scrollable$_handleDragUpdate$1(details) {
      var t1 = this._drag;
      if (t1 != null)
        t1.update$1(0, details);
    },
    _scrollable$_handleDragEnd$1(details) {
      var t2, velocity, t3, isVelocityNotSubstantiallyLessThanCarriedMomentum,
        t1 = this._drag;
      if (t1 != null) {
        t2 = details.primaryVelocity;
        t2.toString;
        velocity = -t2;
        if (A.axisDirectionIsReversed(t1._scroll_activity$_delegate.context._widget.axisDirection))
          velocity = -velocity;
        t1._lastDetails = details;
        if (t1._retainMomentum) {
          t2 = J.get$sign$in(velocity);
          t3 = t1.carriedVelocity;
          isVelocityNotSubstantiallyLessThanCarriedMomentum = Math.abs(velocity) > Math.abs(t3) * 0.5;
          if (t2 === J.get$sign$in(t3) && isVelocityNotSubstantiallyLessThanCarriedMomentum)
            velocity += t3;
        }
        t1._scroll_activity$_delegate.goBallistic$1(velocity);
      }
    },
    _scrollable$_handleDragCancel$0() {
      var t1 = this._hold;
      if (t1 != null)
        t1._scroll_activity$_delegate.goBallistic$1(0);
      t1 = this._drag;
      if (t1 != null)
        t1._scroll_activity$_delegate.goBallistic$1(0);
    },
    _disposeHold$0() {
      this._hold = null;
    },
    _disposeDrag$0() {
      this._drag = null;
    },
    _scrollable$_targetScrollOffsetForPointerScroll$1(delta) {
      var t3,
        t1 = this._scrollable$_position,
        t2 = t1._pixels;
      t2.toString;
      t3 = t1._minScrollExtent;
      t3.toString;
      t3 = Math.max(t2 + delta, t3);
      t1 = t1._maxScrollExtent;
      t1.toString;
      return Math.min(t3, t1);
    },
    _scrollable$_pointerSignalEventDelta$1($event) {
      var delta = A.axisDirectionToAxis(this._widget.axisDirection) === C.Axis_0 ? $event.get$scrollDelta()._dx : $event.get$scrollDelta()._dy;
      return A.boolConversionCheck(A.axisDirectionIsReversed(this._widget.axisDirection)) ? delta * -1 : delta;
    },
    _receivedPointerSignal$1($event) {
      var t1, t2, delta, targetScrollOffset, _this = this;
      type$.PointerSignalEvent._as($event);
      if (type$.PointerScrollEvent._is($event) && _this._scrollable$_position != null) {
        t1 = _this._physics;
        if (t1 != null) {
          t2 = _this._scrollable$_position;
          t2.toString;
          t2 = !t1.shouldAcceptUserOffset$1(t2);
          t1 = t2;
        } else
          t1 = false;
        if (t1)
          return;
        delta = _this._scrollable$_pointerSignalEventDelta$1($event);
        targetScrollOffset = _this._scrollable$_targetScrollOffsetForPointerScroll$1(delta);
        if (delta !== 0) {
          t1 = _this._scrollable$_position._pixels;
          t1.toString;
          t1 = targetScrollOffset !== t1;
        } else
          t1 = false;
        if (t1)
          $.GestureBinding__instance.GestureBinding_pointerSignalResolver.register$2(0, $event, _this.get$_scrollable$_handlePointerScroll());
      } else if (type$.PointerScrollInertiaCancelEvent._is($event))
        _this._scrollable$_position.pointerScroll$1(0);
    },
    _scrollable$_handlePointerScroll$1($event) {
      var t1, _this = this,
        delta = _this._scrollable$_pointerSignalEventDelta$1($event),
        targetScrollOffset = _this._scrollable$_targetScrollOffsetForPointerScroll$1(delta);
      if (delta !== 0) {
        t1 = _this._scrollable$_position._pixels;
        t1.toString;
        t1 = targetScrollOffset !== t1;
      } else
        t1 = false;
      if (t1)
        _this._scrollable$_position.pointerScroll$1(delta);
    },
    _handleScrollMetricsNotification$1(notification) {
      var t1, scrollSemanticsRenderObject;
      if (type$.ScrollMetricsNotification._as(notification).ViewportNotificationMixin__depth === 0) {
        t1 = $.WidgetsBinding__instance.WidgetsBinding__buildOwner._globalKeyRegistry.$index(0, this._scrollSemanticsKey);
        scrollSemanticsRenderObject = t1 == null ? null : t1.get$renderObject();
        if (scrollSemanticsRenderObject != null)
          scrollSemanticsRenderObject.markNeedsSemanticsUpdate$0();
      }
      return false;
    },
    build$1(context) {
      var t2, t3, t4, result, details, registrar, _this = this, _null = null,
        t1 = _this._scrollable$_position;
      t1.toString;
      t2 = _this._gestureRecognizers;
      t3 = _this._widget;
      t4 = t3.excludeFromSemantics;
      result = new B._ScrollableScope(_this, t1, A.Listener$(C.HitTestBehavior_0, new A.RawGestureDetector(A.Semantics$(_null, _null, new A.IgnorePointer(_this._shouldIgnorePointer, false, t3.viewportBuilder$2(context, t1), _this._ignorePointerKey), false, _null, _null, !t4, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null), t2, C.HitTestBehavior_1, t4, _null, _this._gestureDetectorKey), _null, _null, _null, _null, _this.get$_receivedPointerSignal(), _null), _null);
      t1 = _this._widget;
      if (!t1.excludeFromSemantics) {
        t1 = _this._scrollable$_position;
        t1.toString;
        t2 = _this._physics.get$allowImplicitScrolling();
        t3 = _this._widget;
        result = new A.NotificationListener(_this.get$_handleScrollMetricsNotification(), new B._ScrollSemantics(t1, t2, t3.semanticChildCount, result, _this._scrollSemanticsKey), _null, type$.NotificationListener_ScrollMetricsNotification);
        t1 = t3;
      }
      details = new B.ScrollableDetails(t1.axisDirection, _this.get$_effectiveScrollController(), _this._widget.clipBehavior);
      t1 = _this.__ScrollableState__configuration_A;
      t1 === $ && A.throwLateFieldNI("_configuration");
      result = t1.buildScrollbar$3(context, t1.buildOverscrollIndicator$3(context, result, details), details);
      registrar = A.SelectionContainer_maybeOf(context);
      if (registrar != null) {
        t1 = _this._scrollable$_position;
        t1.toString;
        result = new B._ScrollableSelectionHandler(_this, t1, result, registrar, _null);
      }
      return result;
    },
    get$restorationId() {
      return this._widget.restorationId;
    },
    set$_gestureRecognizers(_gestureRecognizers) {
      this._gestureRecognizers = type$.Map_of_Type_and_GestureRecognizerFactory_GestureRecognizer._as(_gestureRecognizers);
    },
    $isTickerProvider: 1,
    $isScrollContext: 1
  };
  B._ScrollableSelectionHandler.prototype = {
    createState$0() {
      return new B._ScrollableSelectionHandlerState(C._StateLifecycle_0);
    }
  };
  B._ScrollableSelectionHandlerState.prototype = {
    initState$0() {
      var t1, t2, t3, t4;
      this.super$State$initState();
      t1 = this._widget;
      t2 = t1.state;
      t1 = t1.position;
      t3 = type$.Selectable;
      t4 = type$.double;
      t3 = new B._ScrollableSelectionContainerDelegate(t2, new B.EdgeDraggingAutoScroller(t2, 30), t1, A.LinkedHashMap_LinkedHashMap$_empty(t3, t4), A.LinkedHashMap_LinkedHashMap$_empty(t3, t4), A._setArrayType([], type$.JSArray_Selectable), A.LinkedHashSet_LinkedHashSet$_empty(t3), D.SelectionGeometry_wEo0, $.$get$ChangeNotifier__emptyListeners());
      t1.addListener$1(0, t3.get$_scheduleLayoutChange());
      this.___ScrollableSelectionHandlerState__selectionDelegate_A = t3;
    },
    didUpdateWidget$1(oldWidget) {
      var t1, t2;
      type$._ScrollableSelectionHandler._as(oldWidget);
      this.super$State$didUpdateWidget(oldWidget);
      t1 = this._widget.position;
      if (oldWidget.position !== t1) {
        t2 = this.___ScrollableSelectionHandlerState__selectionDelegate_A;
        t2 === $ && A.throwLateFieldNI("_selectionDelegate");
        t2.set$position(0, t1);
      }
    },
    dispose$0() {
      var t1 = this.___ScrollableSelectionHandlerState__selectionDelegate_A;
      t1 === $ && A.throwLateFieldNI("_selectionDelegate");
      t1.dispose$0();
      this.super$State$dispose();
    },
    build$1(context) {
      var t1 = this._widget,
        t2 = t1.registrar,
        t3 = this.___ScrollableSelectionHandlerState__selectionDelegate_A;
      t3 === $ && A.throwLateFieldNI("_selectionDelegate");
      return new B.SelectionContainer(t2, t1.child, t3, null);
    }
  };
  B.EdgeDraggingAutoScroller.prototype = {
    _offsetExtent$2(offset, scrollDirection) {
      switch (type$.Axis._as(scrollDirection).index) {
        case 0:
          return offset._dx;
        case 1:
          return offset._dy;
      }
    },
    _sizeExtent$2(size, scrollDirection) {
      switch (type$.Axis._as(scrollDirection).index) {
        case 0:
          return size._dx;
        case 1:
          return size._dy;
      }
    },
    startAutoScrollIfNecessary$1(dragTarget) {
      var _this = this,
        deltaToOrigin = B._getDeltaToScrollOrigin(_this.scrollable);
      _this.__EdgeDraggingAutoScroller__dragTargetRelatedToScrollOrigin_A = dragTarget.translate$2(0, deltaToOrigin._dx, deltaToOrigin._dy);
      if (_this._scrolling)
        return;
      _this._scrollable$_scroll$0();
    },
    _scrollable$_scroll$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$returnValue, $async$self = this, t3, globalRect, deltaToOrigin, t4, viewportStart, viewportEnd, proxyStart, proxyEnd, overDrag, newOffset, duration, t1, t2;
      var $async$_scrollable$_scroll$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.scrollable;
              t2 = t1._framework$_element.get$renderObject();
              t2.toString;
              type$.RenderBox._as(t2);
              t3 = t2.getTransformTo$1(0, null);
              t2 = t2._size;
              globalRect = A.MatrixUtils_transformRect(t3, new A.Rect(0, 0, 0 + t2._dx, 0 + t2._dy));
              t2 = $async$self._scrolling = true;
              deltaToOrigin = B._getDeltaToScrollOrigin(t1);
              t3 = globalRect.left;
              t4 = globalRect.top;
              viewportStart = $async$self._offsetExtent$2(new A.Offset(t3 + deltaToOrigin._dx, t4 + deltaToOrigin._dy), A.axisDirectionToAxis(t1._widget.axisDirection));
              t4 = $async$self._sizeExtent$2(new A.Size(globalRect.right - t3, globalRect.bottom - t4), A.axisDirectionToAxis(t1._widget.axisDirection));
              if (typeof t4 !== "number") {
                $async$returnValue = A.iae(t4);
                // goto return
                $async$goto = 1;
                break;
              }
              viewportEnd = viewportStart + t4;
              t4 = $async$self.__EdgeDraggingAutoScroller__dragTargetRelatedToScrollOrigin_A;
              t4 === $ && A.throwLateFieldNI("_dragTargetRelatedToScrollOrigin");
              proxyStart = $async$self._offsetExtent$2(new A.Offset(t4.left, t4.top), A.axisDirectionToAxis(t1._widget.axisDirection));
              t4 = $async$self.__EdgeDraggingAutoScroller__dragTargetRelatedToScrollOrigin_A;
              proxyEnd = $async$self._offsetExtent$2(new A.Offset(t4.right, t4.bottom), A.axisDirectionToAxis(t1._widget.axisDirection));
              switch (t1._widget.axisDirection.index) {
                case 0:
                case 3:
                  if (proxyEnd > viewportEnd) {
                    t3 = t1._scrollable$_position;
                    t4 = t3._pixels;
                    t4.toString;
                    t3 = t3._minScrollExtent;
                    t3.toString;
                    t3 = t4 > t3;
                  } else
                    t3 = false;
                  if (t3) {
                    overDrag = Math.min(proxyEnd - viewportEnd, 20);
                    t3 = t1._scrollable$_position;
                    t4 = t3._minScrollExtent;
                    t4.toString;
                    t3 = t3._pixels;
                    t3.toString;
                    newOffset = Math.max(t4, t3 - overDrag);
                  } else {
                    if (proxyStart < viewportStart) {
                      t3 = t1._scrollable$_position;
                      t4 = t3._pixels;
                      t4.toString;
                      t3 = t3._maxScrollExtent;
                      t3.toString;
                      t3 = t4 < t3;
                    } else
                      t3 = false;
                    if (t3) {
                      overDrag = Math.min(viewportStart - proxyStart, 20);
                      t3 = t1._scrollable$_position;
                      t4 = t3._maxScrollExtent;
                      t4.toString;
                      t3 = t3._pixels;
                      t3.toString;
                      newOffset = Math.min(t4, t3 + overDrag);
                    } else
                      newOffset = null;
                  }
                  break;
                case 1:
                case 2:
                  if (proxyStart < viewportStart) {
                    t3 = t1._scrollable$_position;
                    t4 = t3._pixels;
                    t4.toString;
                    t3 = t3._minScrollExtent;
                    t3.toString;
                    t3 = t4 > t3;
                  } else
                    t3 = false;
                  if (t3) {
                    overDrag = Math.min(viewportStart - proxyStart, 20);
                    t3 = t1._scrollable$_position;
                    t4 = t3._minScrollExtent;
                    t4.toString;
                    t3 = t3._pixels;
                    t3.toString;
                    newOffset = Math.max(t4, t3 - overDrag);
                  } else {
                    if (proxyEnd > viewportEnd) {
                      t3 = t1._scrollable$_position;
                      t4 = t3._pixels;
                      t4.toString;
                      t3 = t3._maxScrollExtent;
                      t3.toString;
                      t3 = t4 < t3;
                    } else
                      t3 = false;
                    if (t3) {
                      overDrag = Math.min(proxyEnd - viewportEnd, 20);
                      t3 = t1._scrollable$_position;
                      t4 = t3._maxScrollExtent;
                      t4.toString;
                      t3 = t3._pixels;
                      t3.toString;
                      newOffset = Math.min(t4, t3 + overDrag);
                    } else
                      newOffset = null;
                  }
                  break;
                default:
                  newOffset = null;
              }
              if (newOffset != null) {
                t2 = t1._scrollable$_position._pixels;
                t2.toString;
                t2 = Math.abs(newOffset - t2) < 1;
              }
              if (t2) {
                $async$self._scrolling = false;
                // goto return
                $async$goto = 1;
                break;
              }
              duration = A.Duration$(0, C.JSNumber_methods.round$0(1000 / $async$self.velocityScalar), 0);
              $async$goto = 3;
              return A._asyncAwait(t1._scrollable$_position.animateTo$3$curve$duration(newOffset, C.C__Linear, duration), $async$_scrollable$_scroll$0);
            case 3:
              // returning from await.
              $async$goto = $async$self._scrolling ? 4 : 5;
              break;
            case 4:
              // then
              $async$goto = 6;
              return A._asyncAwait($async$self._scrollable$_scroll$0(), $async$_scrollable$_scroll$0);
            case 6:
              // returning from await.
            case 5:
              // join
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$_scrollable$_scroll$0, $async$completer);
    }
  };
  B._ScrollableSelectionContainerDelegate.prototype = {
    set$position(_, other) {
      var t2,
        t1 = this._scrollable$_position;
      if (other === t1)
        return;
      t2 = this.get$_scheduleLayoutChange();
      t1.removeListener$1(0, t2);
      this._scrollable$_position = other;
      other.addListener$1(0, t2);
    },
    _scheduleLayoutChange$0() {
      if (this._scheduledLayoutChange)
        return;
      this._scheduledLayoutChange = true;
      var t1 = $.SchedulerBinding__instance;
      t1.toString;
      C.JSArray_methods.add$1(t1.SchedulerBinding__postFrameCallbacks, type$.void_Function_Duration._as(new B._ScrollableSelectionContainerDelegate__scheduleLayoutChange_closure(this)));
    },
    didChangeSelectables$0() {
      var _this = this,
        t1 = _this.selectables,
        selectableSet = A.LinkedHashSet_LinkedHashSet$from(t1, A._arrayInstanceType(t1)._precomputed1);
      t1 = _this._selectableStartEdgeUpdateRecords;
      t1.removeWhere$1(t1, new B._ScrollableSelectionContainerDelegate_didChangeSelectables_closure(selectableSet));
      t1 = _this._selectableEndEdgeUpdateRecords;
      t1.removeWhere$1(t1, new B._ScrollableSelectionContainerDelegate_didChangeSelectables_closure0(selectableSet));
      _this.super$MultiSelectableSelectionContainerDelegate$didChangeSelectables();
    },
    handleClearSelection$1($event) {
      var _this = this;
      _this._selectableStartEdgeUpdateRecords.clear$0(0);
      _this._selectableEndEdgeUpdateRecords.clear$0(0);
      _this._currentDragEndRelatedToOrigin = _this._currentDragStartRelatedToOrigin = null;
      _this._selectionStartsInScrollable = false;
      return _this.super$MultiSelectableSelectionContainerDelegate$handleClearSelection($event);
    },
    handleSelectionEdgeUpdate$1($event) {
      var deltaToOrigin, t1, t2, t3, result, _this = this;
      if (_this._currentDragEndRelatedToOrigin == null && _this._currentDragStartRelatedToOrigin == null)
        _this._selectionStartsInScrollable = _this._globalPositionInScrollable$1($event.globalPosition);
      deltaToOrigin = B._getDeltaToScrollOrigin(_this.state);
      t1 = $event.globalPosition;
      t2 = -deltaToOrigin._dx;
      t3 = -deltaToOrigin._dy;
      if ($event.type === C.SelectionEventType_1) {
        t1 = _this._currentDragEndRelatedToOrigin = _this._inferPositionRelatedToOrigin$1(t1);
        $event = new B.SelectionEdgeUpdateEvent(new A.Offset(t1._dx + t2, t1._dy + t3), C.SelectionEventType_1);
      } else {
        t1 = _this._currentDragStartRelatedToOrigin = _this._inferPositionRelatedToOrigin$1(t1);
        $event = new B.SelectionEdgeUpdateEvent(new A.Offset(t1._dx + t2, t1._dy + t3), C.SelectionEventType_0);
      }
      result = _this.super$MultiSelectableSelectionContainerDelegate$handleSelectionEdgeUpdate($event);
      if (result === D.SelectionResult_3) {
        _this._autoScroller._scrolling = false;
        return result;
      }
      if (_this._selectionStartsInScrollable) {
        t1 = _this._autoScroller;
        t1.startAutoScrollIfNecessary$1(A.Rect$fromCenter($event.globalPosition, 0, 0));
        if (t1._scrolling)
          return D.SelectionResult_3;
      }
      return result;
    },
    _inferPositionRelatedToOrigin$1(globalPosition) {
      var localPosition, t3, t4, deltaToOrigin,
        t1 = this.state,
        t2 = t1._framework$_element.get$renderObject();
      t2.toString;
      type$.RenderBox._as(t2);
      localPosition = t2.globalToLocal$1(globalPosition);
      if (!this._selectionStartsInScrollable) {
        t3 = localPosition._dy;
        if (t3 < 0 || localPosition._dx < 0)
          return A.MatrixUtils_transformPoint(t2.getTransformTo$1(0, null), C.Offset_0_0);
        t4 = t2._size;
        if (t3 > t4._dy || localPosition._dx > t4._dx)
          return D.Offset_YZQ;
      }
      deltaToOrigin = B._getDeltaToScrollOrigin(t1);
      t1 = deltaToOrigin._dx;
      t3 = deltaToOrigin._dy;
      return A.MatrixUtils_transformPoint(t2.getTransformTo$1(0, null), new A.Offset(localPosition._dx + t1, localPosition._dy + t3));
    },
    _updateDragLocationsFromGeometries$2$forceUpdateEnd$forceUpdateStart(forceUpdateEnd, forceUpdateStart) {
      var transform, t2, t3, t4, _this = this,
        t1 = _this.state,
        deltaToOrigin = B._getDeltaToScrollOrigin(t1);
      t1 = t1._framework$_element.get$renderObject();
      t1.toString;
      type$.RenderBox._as(t1);
      transform = t1.getTransformTo$1(0, null);
      t2 = _this.currentSelectionStartIndex;
      if (t2 !== -1)
        t3 = _this._currentDragStartRelatedToOrigin == null || forceUpdateStart;
      else
        t3 = false;
      if (t3) {
        t3 = _this.selectables;
        if (!(t2 >= 0 && t2 < t3.length))
          return A.ioore(t3, t2);
        t2 = J.get$value$z(t3[t2]).startSelectionPoint;
        t2.toString;
        t3 = _this.selectables;
        t4 = _this.currentSelectionStartIndex;
        if (!(t4 >= 0 && t4 < t3.length))
          return A.ioore(t3, t4);
        _this._currentDragStartRelatedToOrigin = A.MatrixUtils_transformPoint(transform, A.MatrixUtils_transformPoint(J.getTransformTo$1$z(t3[t4], t1), t2.localPosition.$add(0, new A.Offset(0, -t2.lineHeight / 2))).$add(0, deltaToOrigin));
      }
      t2 = _this.currentSelectionEndIndex;
      if (t2 !== -1)
        t3 = _this._currentDragEndRelatedToOrigin == null || forceUpdateEnd;
      else
        t3 = false;
      if (t3) {
        t3 = _this.selectables;
        if (!(t2 >= 0 && t2 < t3.length))
          return A.ioore(t3, t2);
        t2 = J.get$value$z(t3[t2]).endSelectionPoint;
        t2.toString;
        t3 = _this.selectables;
        t4 = _this.currentSelectionEndIndex;
        if (!(t4 >= 0 && t4 < t3.length))
          return A.ioore(t3, t4);
        _this._currentDragEndRelatedToOrigin = A.MatrixUtils_transformPoint(transform, A.MatrixUtils_transformPoint(J.getTransformTo$1$z(t3[t4], t1), t2.localPosition.$add(0, new A.Offset(0, -t2.lineHeight / 2))).$add(0, deltaToOrigin));
      }
    },
    _updateDragLocationsFromGeometries$0() {
      return this._updateDragLocationsFromGeometries$2$forceUpdateEnd$forceUpdateStart(true, true);
    },
    handleSelectAll$1($event) {
      var result = this.super$MultiSelectableSelectionContainerDelegate$handleSelectAll($event);
      if (this.currentSelectionStartIndex !== -1)
        this._updateDragLocationsFromGeometries$0();
      return result;
    },
    handleSelectWord$1($event) {
      var result, _this = this;
      _this._selectionStartsInScrollable = _this._globalPositionInScrollable$1($event.globalPosition);
      result = _this.super$MultiSelectableSelectionContainerDelegate$handleSelectWord($event);
      _this._updateDragLocationsFromGeometries$0();
      return result;
    },
    handleGranularlyExtendSelection$1($event) {
      var _this = this,
        result = _this.super$MultiSelectableSelectionContainerDelegate$handleGranularlyExtendSelection($event),
        t1 = $event.isEnd;
      _this._updateDragLocationsFromGeometries$2$forceUpdateEnd$forceUpdateStart(t1, !t1);
      if (_this._selectionStartsInScrollable)
        _this._jumpToEdge$1(t1);
      return result;
    },
    handleDirectionallyExtendSelection$1($event) {
      var _this = this,
        result = _this.super$MultiSelectableSelectionContainerDelegate$handleDirectionallyExtendSelection($event),
        t1 = $event.isEnd;
      _this._updateDragLocationsFromGeometries$2$forceUpdateEnd$forceUpdateStart(t1, !t1);
      if (_this._selectionStartsInScrollable)
        _this._jumpToEdge$1(t1);
      return result;
    },
    _jumpToEdge$1(isExtent) {
      var t3, selectable, edge, lineHeight, edgeOffsetInScrollableCoordinates, edgeBottom, edgeTop, _this = this,
        t1 = _this.selectables,
        t2 = t1.length;
      if (isExtent) {
        t3 = _this.currentSelectionEndIndex;
        if (!(t3 >= 0 && t3 < t2))
          return A.ioore(t1, t3);
        selectable = t1[t3];
        edge = selectable.get$value(selectable).endSelectionPoint;
        lineHeight = selectable.get$value(selectable).endSelectionPoint.lineHeight;
      } else {
        t3 = _this.currentSelectionStartIndex;
        if (!(t3 >= 0 && t3 < t2))
          return A.ioore(t1, t3);
        selectable = t1[t3];
        edge = selectable.get$value(selectable).startSelectionPoint;
        t3 = selectable.get$value(selectable).startSelectionPoint;
        lineHeight = t3 == null ? null : t3.lineHeight;
      }
      if (lineHeight == null || edge == null)
        return;
      t1 = _this.state;
      t2 = t1._framework$_element.get$renderObject();
      t2.toString;
      type$.RenderBox._as(t2);
      edgeOffsetInScrollableCoordinates = A.MatrixUtils_transformPoint(selectable.getTransformTo$1(0, t2), edge.localPosition);
      t2 = t2._size;
      t3 = t2._dx;
      t2 = t2._dy;
      switch (t1._widget.axisDirection.index) {
        case 0:
          edgeBottom = edgeOffsetInScrollableCoordinates._dy;
          if (typeof lineHeight !== "number")
            return A.iae(lineHeight);
          edgeTop = edgeBottom - lineHeight;
          if (edgeBottom >= t2 && edgeTop <= 0)
            return;
          if (edgeBottom > t2) {
            t1 = _this._scrollable$_position;
            t3 = t1._pixels;
            t3.toString;
            t1.jumpTo$1(t3 + t2 - edgeBottom);
            return;
          }
          if (edgeTop < 0) {
            t1 = _this._scrollable$_position;
            t2 = t1._pixels;
            t2.toString;
            t1.jumpTo$1(t2 + 0 - edgeTop);
          }
          return;
        case 1:
          edge = edgeOffsetInScrollableCoordinates._dx;
          if (edge >= t3 && edge <= 0)
            return;
          if (edge > t3) {
            t1 = _this._scrollable$_position;
            t2 = t1._pixels;
            t2.toString;
            t1.jumpTo$1(t2 + edge - t3);
            return;
          }
          if (edge < 0) {
            t1 = _this._scrollable$_position;
            t2 = t1._pixels;
            t2.toString;
            t1.jumpTo$1(t2 + edge - 0);
          }
          return;
        case 2:
          edgeBottom = edgeOffsetInScrollableCoordinates._dy;
          if (typeof lineHeight !== "number")
            return A.iae(lineHeight);
          edgeTop = edgeBottom - lineHeight;
          if (edgeBottom >= t2 && edgeTop <= 0)
            return;
          if (edgeBottom > t2) {
            t1 = _this._scrollable$_position;
            t3 = t1._pixels;
            t3.toString;
            t1.jumpTo$1(t3 + edgeBottom - t2);
            return;
          }
          if (edgeTop < 0) {
            t1 = _this._scrollable$_position;
            t2 = t1._pixels;
            t2.toString;
            t1.jumpTo$1(t2 + edgeTop - 0);
          }
          return;
        case 3:
          edge = edgeOffsetInScrollableCoordinates._dx;
          if (edge >= t3 && edge <= 0)
            return;
          if (edge > t3) {
            t1 = _this._scrollable$_position;
            t2 = t1._pixels;
            t2.toString;
            t1.jumpTo$1(t2 + t3 - edge);
            return;
          }
          if (edge < 0) {
            t1 = _this._scrollable$_position;
            t2 = t1._pixels;
            t2.toString;
            t1.jumpTo$1(t2 + 0 - edge);
          }
          return;
      }
    },
    _globalPositionInScrollable$1(globalPosition) {
      var localPosition,
        t1 = this.state._framework$_element.get$renderObject();
      t1.toString;
      type$.RenderBox._as(t1);
      localPosition = t1.globalToLocal$1(globalPosition);
      t1 = t1._size;
      return new A.Rect(0, 0, 0 + t1._dx, 0 + t1._dy).contains$1(0, localPosition);
    },
    dispatchSelectionEventToChild$2(selectable, $event) {
      var t1, t2, _this = this;
      switch ($event.type.index) {
        case 0:
          t1 = _this.state._scrollable$_position._pixels;
          t1.toString;
          _this._selectableStartEdgeUpdateRecords.$indexSet(0, selectable, t1);
          _this.ensureChildUpdated$1(selectable);
          break;
        case 1:
          t1 = _this.state._scrollable$_position._pixels;
          t1.toString;
          _this._selectableEndEdgeUpdateRecords.$indexSet(0, selectable, t1);
          _this.ensureChildUpdated$1(selectable);
          break;
        case 5:
        case 6:
          _this.ensureChildUpdated$1(selectable);
          t1 = _this.state;
          t2 = t1._scrollable$_position._pixels;
          t2.toString;
          _this._selectableStartEdgeUpdateRecords.$indexSet(0, selectable, t2);
          t1 = t1._scrollable$_position._pixels;
          t1.toString;
          _this._selectableEndEdgeUpdateRecords.$indexSet(0, selectable, t1);
          break;
        case 2:
          _this._selectableEndEdgeUpdateRecords.remove$1(0, selectable);
          _this._selectableStartEdgeUpdateRecords.remove$1(0, selectable);
          break;
        case 3:
        case 4:
          t1 = _this.state;
          t2 = t1._scrollable$_position._pixels;
          t2.toString;
          _this._selectableEndEdgeUpdateRecords.$indexSet(0, selectable, t2);
          t1 = t1._scrollable$_position._pixels;
          t1.toString;
          _this._selectableStartEdgeUpdateRecords.$indexSet(0, selectable, t1);
          break;
      }
      return _this.super$MultiSelectableSelectionContainerDelegate$dispatchSelectionEventToChild(selectable, $event);
    },
    ensureChildUpdated$1(selectable) {
      var previousStartRecord, t3, t4, deltaToOrigin, t5, previousEndRecord, _this = this,
        t1 = _this.state,
        t2 = t1._scrollable$_position._pixels;
      t2.toString;
      previousStartRecord = _this._selectableStartEdgeUpdateRecords.$index(0, selectable);
      t3 = _this._currentDragStartRelatedToOrigin;
      if (t3 != null)
        t4 = previousStartRecord == null || Math.abs(t2 - previousStartRecord) > 1e-10;
      else
        t4 = false;
      if (t4) {
        deltaToOrigin = B._getDeltaToScrollOrigin(t1);
        t4 = deltaToOrigin._dx;
        t5 = deltaToOrigin._dy;
        selectable.dispatchSelectionEvent$1(new B.SelectionEdgeUpdateEvent(new A.Offset(t3._dx + -t4, t3._dy + -t5), C.SelectionEventType_0));
      }
      previousEndRecord = _this._selectableEndEdgeUpdateRecords.$index(0, selectable);
      t3 = _this._currentDragEndRelatedToOrigin;
      if (t3 != null)
        t2 = previousEndRecord == null || Math.abs(t2 - previousEndRecord) > 1e-10;
      else
        t2 = false;
      if (t2) {
        deltaToOrigin = B._getDeltaToScrollOrigin(t1);
        t1 = deltaToOrigin._dx;
        t2 = deltaToOrigin._dy;
        selectable.dispatchSelectionEvent$1(new B.SelectionEdgeUpdateEvent(new A.Offset(t3._dx + -t1, t3._dy + -t2), C.SelectionEventType_1));
      }
    },
    dispose$0() {
      var _this = this;
      _this._selectableStartEdgeUpdateRecords.clear$0(0);
      _this._selectableEndEdgeUpdateRecords.clear$0(0);
      _this._scheduledLayoutChange = false;
      _this._autoScroller._scrolling = false;
      _this.super$MultiSelectableSelectionContainerDelegate$dispose();
    }
  };
  B.ScrollableDetails.prototype = {};
  B._ScrollSemantics.prototype = {
    createRenderObject$1(context) {
      var t1 = this.position,
        t2 = new B._RenderScrollSemantics(t1, this.allowImplicitScrolling, this.semanticChildCount, null, A.LayerHandle$(type$.ContainerLayer));
      t2.RenderObject$0();
      t2.set$child(null);
      t1.addListener$1(0, t2.get$markNeedsSemanticsUpdate());
      return t2;
    },
    updateRenderObject$2(context, renderObject) {
      type$._RenderScrollSemantics._as(renderObject);
      renderObject.set$allowImplicitScrolling(this.allowImplicitScrolling);
      renderObject.set$position(0, this.position);
      renderObject.set$semanticChildCount(this.semanticChildCount);
    }
  };
  B._RenderScrollSemantics.prototype = {
    set$position(_, value) {
      var t2, _this = this,
        t1 = _this._scrollable$_position;
      if (value === t1)
        return;
      t2 = _this.get$markNeedsSemanticsUpdate();
      t1.removeListener$1(0, t2);
      _this._scrollable$_position = value;
      value.addListener$1(0, t2);
      _this.markNeedsSemanticsUpdate$0();
    },
    set$allowImplicitScrolling(value) {
      if (value === this._allowImplicitScrolling)
        return;
      this._allowImplicitScrolling = value;
      this.markNeedsSemanticsUpdate$0();
    },
    set$semanticChildCount(value) {
      if (value == this._semanticChildCount)
        return;
      this._semanticChildCount = value;
      this.markNeedsSemanticsUpdate$0();
    },
    describeSemanticsConfiguration$1(config) {
      var t1, t2, _this = this;
      _this.super$RenderObject$describeSemanticsConfiguration(config);
      config._isSemanticBoundary = true;
      if (_this._scrollable$_position._haveDimensions) {
        config._setFlag$2(C.SemanticsFlag_262144, _this._allowImplicitScrolling);
        t1 = _this._scrollable$_position;
        t2 = t1._pixels;
        t2.toString;
        config._scrollPosition = t2;
        config._hasBeenAnnotated = true;
        t2 = t1._maxScrollExtent;
        t2.toString;
        config._scrollExtentMax = t2;
        t1 = t1._minScrollExtent;
        t1.toString;
        config._scrollExtentMin = t1;
        config.set$scrollChildCount(_this._semanticChildCount);
      }
    },
    assembleSemanticsNode$3(node, config, children) {
      var t1, t2, excluded, included, firstVisibleIndex, _i, child, _this = this;
      type$.Iterable_SemanticsNode._as(children);
      if (children.length !== 0) {
        t1 = C.JSArray_methods.get$first(children).tags;
        t1 = !(t1 != null && t1.contains$1(0, D.SemanticsTag_FIw));
      } else
        t1 = true;
      if (t1) {
        _this.super$RenderObject$assembleSemanticsNode(node, config, children);
        return;
      }
      t1 = _this._innerNode;
      if (t1 == null)
        t1 = _this._innerNode = A.SemanticsNode$(null, _this.get$showOnScreen());
      t1.set$isMergedIntoParent(node._mergeAllDescendantsIntoThisNode || node._isMergedIntoParent);
      t1.set$rect(0, node._semantics$_rect);
      t1 = _this._innerNode;
      t1.toString;
      t2 = type$.JSArray_SemanticsNode;
      excluded = A._setArrayType([t1], t2);
      included = A._setArrayType([], t2);
      for (t1 = children.length, firstVisibleIndex = null, _i = 0; _i < children.length; children.length === t1 || (0, A.throwConcurrentModificationError)(children), ++_i) {
        child = children[_i];
        t2 = child.tags;
        if (t2 != null && t2.contains$1(0, D.SemanticsTag_bQQ))
          C.JSArray_methods.add$1(excluded, child);
        else {
          if ((child._flags & 8192) === 0)
            firstVisibleIndex = firstVisibleIndex == null ? child.indexInParent : firstVisibleIndex;
          C.JSArray_methods.add$1(included, child);
        }
      }
      config.set$scrollIndex(firstVisibleIndex);
      node.updateWith$2$childrenInInversePaintOrder$config(0, excluded, null);
      _this._innerNode.updateWith$2$childrenInInversePaintOrder$config(0, included, config);
    },
    clearSemantics$0() {
      this.super$RenderObject$clearSemantics();
      this._innerNode = null;
    }
  };
  B._RestorableScrollOffset.prototype = {
    createDefaultValue$0() {
      return null;
    },
    didUpdateValue$1(oldValue) {
      A._asDoubleQ(oldValue);
      this.notifyListeners$0();
    },
    fromPrimitives$1(data) {
      data.toString;
      return A._asDouble(data);
    },
    toPrimitives$0() {
      var t1 = this._restoration_properties$_value;
      return t1 == null ? A._instanceType(this)._eval$1("RestorableValue.T")._as(t1) : t1;
    },
    get$enabled(_) {
      var t1 = this._restoration_properties$_value;
      return (t1 == null ? A._instanceType(this)._eval$1("RestorableValue.T")._as(t1) : t1) != null;
    }
  };
  B._ScrollableState_State_TickerProviderStateMixin.prototype = {
    activate$0() {
      this.super$State$activate();
      this._updateTickerModeNotifier$0();
      this._updateTickers$0();
    },
    dispose$0() {
      var _this = this,
        t1 = _this.TickerProviderStateMixin__tickerModeNotifier;
      if (t1 != null)
        t1.removeListener$1(0, _this.get$_updateTickers());
      _this.set$_tickerModeNotifier(null);
      _this.super$State$dispose();
    }
  };
  B._ScrollableState_State_TickerProviderStateMixin_RestorationMixin.prototype = {
    didUpdateWidget$1(oldWidget) {
      this.super$State$didUpdateWidget(type$.Scrollable._as(oldWidget));
      this.didUpdateRestorationId$0();
    },
    didChangeDependencies$0() {
      var oldBucket, needsRestore, t1, didReplaceBucket, _this = this;
      _this.super$State$didChangeDependencies();
      oldBucket = _this.RestorationMixin__bucket;
      needsRestore = _this.get$restorePending();
      t1 = _this._framework$_element;
      t1.toString;
      t1 = A.RestorationScope_maybeOf(t1);
      _this.RestorationMixin__currentParent = t1;
      didReplaceBucket = _this._updateBucketIfNecessary$2$parent$restorePending(t1, needsRestore);
      if (needsRestore) {
        _this.restoreState$2(oldBucket, _this.RestorationMixin__firstRestorePending);
        _this.RestorationMixin__firstRestorePending = false;
      }
      if (didReplaceBucket)
        if (oldBucket != null)
          oldBucket.dispose$0();
    },
    dispose$0() {
      var t1, _this = this;
      _this.RestorationMixin__properties.forEach$1(0, new B._ScrollableState_State_TickerProviderStateMixin_RestorationMixin_dispose_closure());
      t1 = _this.RestorationMixin__bucket;
      if (t1 != null)
        t1.dispose$0();
      _this.RestorationMixin__bucket = null;
      _this.super$_ScrollableState_State_TickerProviderStateMixin$dispose();
    }
  };
  B.MultiSelectableSelectionContainerDelegate.prototype = {
    add$1(_, selectable) {
      type$.Selectable._as(selectable);
      this._additions.add$1(0, selectable);
      this._scheduleSelectableUpdate$0();
    },
    remove$1(_, selectable) {
      var index, t1, _this = this;
      type$.Selectable._as(selectable);
      if (_this._additions.remove$1(0, selectable))
        return;
      index = C.JSArray_methods.indexOf$1(_this.selectables, selectable);
      C.JSArray_methods.removeAt$1(_this.selectables, index);
      t1 = _this.currentSelectionEndIndex;
      if (index <= t1)
        _this.currentSelectionEndIndex = t1 - 1;
      t1 = _this.currentSelectionStartIndex;
      if (index <= t1)
        _this.currentSelectionStartIndex = t1 - 1;
      selectable.removeListener$1(0, _this.get$_handleSelectableGeometryChange());
      _this._scheduleSelectableUpdate$0();
    },
    _scheduleSelectableUpdate$0() {
      if (!this._scheduledSelectableUpdate) {
        this._scheduledSelectableUpdate = true;
        var t1 = $.SchedulerBinding__instance;
        t1.toString;
        C.JSArray_methods.add$1(t1.SchedulerBinding__postFrameCallbacks, type$.void_Function_Duration._as(new B.MultiSelectableSelectionContainerDelegate__scheduleSelectableUpdate_closure(this)));
      }
    },
    _flushAdditions$0() {
      var existingSelectables, selectionStartIndex, selectionEndIndex, mergingIndex, existingIndex, t2, t3, mergingSelectable, _this = this,
        t1 = _this._additions,
        mergingSelectables = A.List_List$of(t1, true, A._instanceType(t1)._precomputed1);
      C.JSArray_methods.sort$1(mergingSelectables, _this.get$_compareScreenOrder());
      existingSelectables = _this.selectables;
      _this.set$selectables(A._setArrayType([], type$.JSArray_Selectable));
      selectionStartIndex = _this.currentSelectionStartIndex;
      selectionEndIndex = _this.currentSelectionEndIndex;
      t1 = _this.get$_handleSelectableGeometryChange();
      mergingIndex = 0;
      existingIndex = 0;
      while (true) {
        t2 = mergingSelectables.length;
        if (!(mergingIndex < t2 || existingIndex < existingSelectables.length))
          break;
        c$0: {
          if (mergingIndex < t2)
            if (existingIndex < existingSelectables.length) {
              t3 = existingSelectables[existingIndex];
              if (!(mergingIndex < t2))
                return A.ioore(mergingSelectables, mergingIndex);
              t3 = _this.compareOrder$2(t3, mergingSelectables[mergingIndex]);
              if (typeof t3 !== "number")
                return t3.$lt();
              t3 = t3 < 0;
              t2 = t3;
            } else
              t2 = false;
          else
            t2 = true;
          if (t2) {
            if (existingIndex === _this.currentSelectionStartIndex)
              selectionStartIndex = _this.selectables.length;
            if (existingIndex === _this.currentSelectionEndIndex)
              selectionEndIndex = _this.selectables.length;
            t2 = _this.selectables;
            if (!(existingIndex < existingSelectables.length))
              return A.ioore(existingSelectables, existingIndex);
            C.JSArray_methods.add$1(t2, existingSelectables[existingIndex]);
            ++existingIndex;
            break c$0;
          }
          if (!(mergingIndex < mergingSelectables.length))
            return A.ioore(mergingSelectables, mergingIndex);
          mergingSelectable = mergingSelectables[mergingIndex];
          t2 = _this.currentSelectionStartIndex;
          t3 = _this.currentSelectionEndIndex;
          if (existingIndex < Math.max(t2, t3) && existingIndex > Math.min(t2, t3))
            _this.ensureChildUpdated$1(mergingSelectable);
          mergingSelectable.addListener$1(0, t1);
          C.JSArray_methods.add$1(_this.selectables, mergingSelectable);
          ++mergingIndex;
        }
      }
      _this.currentSelectionEndIndex = selectionEndIndex;
      _this.currentSelectionStartIndex = selectionStartIndex;
      _this.set$_additions(A.LinkedHashSet_LinkedHashSet$_empty(type$.Selectable));
    },
    didChangeSelectables$0() {
      this._updateSelectionGeometry$0();
    },
    _updateSelectionGeometry$0() {
      var _this = this,
        newValue = _this.getSelectionGeometry$0();
      if (!_this._selectionGeometry.$eq(0, newValue)) {
        _this._selectionGeometry = newValue;
        _this.notifyListeners$0();
      }
      _this._updateHandleLayersAndOwners$0();
    },
    get$compareOrder() {
      return this.get$_compareScreenOrder();
    },
    _compareScreenOrder$2(a, b) {
      var rectA, rectB, result,
        t1 = type$.Selectable;
      t1._as(a);
      t1._as(b);
      rectA = A.MatrixUtils_transformRect(a.getTransformTo$1(0, null), new A.Rect(0, 0, 0 + a.get$size(a)._dx, 0 + a.get$size(a)._dy));
      rectB = A.MatrixUtils_transformRect(b.getTransformTo$1(0, null), new A.Rect(0, 0, 0 + b.get$size(b)._dx, 0 + b.get$size(b)._dy));
      result = B.MultiSelectableSelectionContainerDelegate__compareVertically(rectA, rectB);
      if (result !== 0)
        return result;
      return B.MultiSelectableSelectionContainerDelegate__compareHorizontally(rectA, rectB);
    },
    _handleSelectableGeometryChange$0() {
      if (this._isHandlingSelectionEvent)
        return;
      this._updateSelectionGeometry$0();
    },
    getSelectionGeometry$0() {
      var t2, startGeometry, startIndexWalker, forwardSelection, t3, start, startPoint, endGeometry, endIndexWalker, end, endPoint, _this = this, _null = null,
        t1 = _this.currentSelectionEndIndex;
      if (t1 === -1 || _this.currentSelectionStartIndex === -1 || _this.selectables.length === 0)
        return new A.SelectionGeometry(_null, _null, C.SelectionStatus_2, _this.selectables.length !== 0);
      if (!_this._extendSelectionInProgress) {
        t1 = _this._adjustSelectionIndexBasedOnSelectionGeometry$2(_this.currentSelectionStartIndex, t1);
        _this.currentSelectionStartIndex = t1;
        _this.currentSelectionEndIndex = _this._adjustSelectionIndexBasedOnSelectionGeometry$2(_this.currentSelectionEndIndex, t1);
      }
      t1 = _this.selectables;
      t2 = _this.currentSelectionStartIndex;
      if (!(t2 >= 0 && t2 < t1.length))
        return A.ioore(t1, t2);
      startGeometry = J.get$value$z(t1[t2]);
      t2 = _this.currentSelectionEndIndex;
      startIndexWalker = _this.currentSelectionStartIndex;
      forwardSelection = t2 >= startIndexWalker;
      while (true) {
        if (!(startIndexWalker !== _this.currentSelectionEndIndex && startGeometry.startSelectionPoint == null))
          break;
        startIndexWalker += forwardSelection ? 1 : -1;
        t1 = _this.selectables;
        if (!(startIndexWalker >= 0 && startIndexWalker < t1.length))
          return A.ioore(t1, startIndexWalker);
        startGeometry = J.get$value$z(t1[startIndexWalker]);
      }
      t1 = startGeometry.startSelectionPoint;
      if (t1 != null) {
        t2 = _this.selectables;
        if (!(startIndexWalker >= 0 && startIndexWalker < t2.length))
          return A.ioore(t2, startIndexWalker);
        t2 = type$.Selectable._as(t2[startIndexWalker]);
        t3 = _this._selectionContainerContext.get$renderObject();
        t3.toString;
        start = A.MatrixUtils_transformPoint(t2.getTransformTo$1(0, type$.RenderBox._as(t3)), t1.localPosition);
        startPoint = isFinite(start._dx) && isFinite(start._dy) ? new A.SelectionPoint(start, t1.lineHeight, t1.handleType) : _null;
      } else
        startPoint = _null;
      t1 = _this.selectables;
      t2 = _this.currentSelectionEndIndex;
      if (!(t2 >= 0 && t2 < t1.length))
        return A.ioore(t1, t2);
      endGeometry = J.get$value$z(t1[t2]);
      endIndexWalker = _this.currentSelectionEndIndex;
      while (true) {
        if (!(endIndexWalker !== _this.currentSelectionStartIndex && endGeometry.endSelectionPoint == null))
          break;
        endIndexWalker += forwardSelection ? -1 : 1;
        t1 = _this.selectables;
        if (!(endIndexWalker >= 0 && endIndexWalker < t1.length))
          return A.ioore(t1, endIndexWalker);
        endGeometry = J.get$value$z(t1[endIndexWalker]);
      }
      t1 = endGeometry.endSelectionPoint;
      if (t1 != null) {
        t2 = _this.selectables;
        if (!(endIndexWalker >= 0 && endIndexWalker < t2.length))
          return A.ioore(t2, endIndexWalker);
        t2 = type$.Selectable._as(t2[endIndexWalker]);
        t3 = _this._selectionContainerContext.get$renderObject();
        t3.toString;
        end = A.MatrixUtils_transformPoint(t2.getTransformTo$1(0, type$.RenderBox._as(t3)), t1.localPosition);
        endPoint = isFinite(end._dx) && isFinite(end._dy) ? new A.SelectionPoint(end, t1.lineHeight, t1.handleType) : _null;
      } else
        endPoint = _null;
      return new A.SelectionGeometry(startPoint, endPoint, !startGeometry.$eq(0, endGeometry) ? C.SelectionStatus_0 : startGeometry.status, true);
    },
    _adjustSelectionIndexBasedOnSelectionGeometry$2(currentIndex, towardIndex) {
      var t1,
        $forward = towardIndex > currentIndex;
      while (true) {
        if (currentIndex !== towardIndex) {
          t1 = this.selectables;
          if (!(currentIndex >= 0 && currentIndex < t1.length))
            return A.ioore(t1, currentIndex);
          t1 = J.get$value$z(t1[currentIndex]).status !== C.SelectionStatus_0;
        } else
          t1 = false;
        if (!t1)
          break;
        currentIndex += $forward ? 1 : -1;
      }
      return currentIndex;
    },
    pushHandleLayers$2(startHandle, endHandle) {
      var _this = this;
      if (_this._startHandleLayer == startHandle && _this._endHandleLayer == endHandle)
        return;
      _this._startHandleLayer = startHandle;
      _this._endHandleLayer = endHandle;
      _this._updateHandleLayersAndOwners$0();
    },
    _updateHandleLayersAndOwners$0() {
      var drawableArea, t1, hideStartHandle, hideEndHandle, t2, _this = this, _null = null,
        effectiveStartHandle = _this._startHandleLayer,
        effectiveEndHandle = _this._endHandleLayer;
      if (effectiveStartHandle != null || effectiveEndHandle != null) {
        drawableArea = new A.Rect(0, 0, 0 + _this.get$containerSize()._dx, 0 + _this.get$containerSize()._dy).inflate$1(5);
        t1 = _this._selectionGeometry.startSelectionPoint;
        hideStartHandle = t1 == null || !drawableArea.contains$1(0, t1.localPosition);
        t1 = _this._selectionGeometry.endSelectionPoint;
        hideEndHandle = t1 == null || !drawableArea.contains$1(0, t1.localPosition);
        effectiveStartHandle = hideStartHandle ? _null : _this._startHandleLayer;
        effectiveEndHandle = hideEndHandle ? _null : _this._endHandleLayer;
      }
      t1 = _this.currentSelectionStartIndex;
      if (t1 === -1 || _this.currentSelectionEndIndex === -1) {
        t1 = _this._startHandleLayerOwner;
        if (t1 != null) {
          t1.pushHandleLayers$2(_null, _null);
          _this._startHandleLayerOwner = null;
        }
        t1 = _this._endHandleLayerOwner;
        if (t1 != null) {
          t1.pushHandleLayers$2(_null, _null);
          _this._endHandleLayerOwner = null;
        }
        return;
      }
      t2 = _this.selectables;
      if (!(t1 >= 0 && t1 < t2.length))
        return A.ioore(t2, t1);
      if (!J.$eq$(t2[t1], _this._startHandleLayerOwner)) {
        t1 = _this._startHandleLayerOwner;
        if (t1 != null)
          t1.pushHandleLayers$2(_null, _null);
      }
      t1 = _this.selectables;
      t2 = _this.currentSelectionEndIndex;
      if (!(t2 >= 0 && t2 < t1.length))
        return A.ioore(t1, t2);
      if (!J.$eq$(t1[t2], _this._endHandleLayerOwner)) {
        t1 = _this._endHandleLayerOwner;
        if (t1 != null)
          t1.pushHandleLayers$2(_null, _null);
      }
      t1 = _this.selectables;
      t2 = _this.currentSelectionStartIndex;
      if (!(t2 >= 0 && t2 < t1.length))
        return A.ioore(t1, t2);
      _this.set$_startHandleLayerOwner(t1[t2]);
      if (_this.currentSelectionStartIndex === _this.currentSelectionEndIndex) {
        t1 = _this._startHandleLayerOwner;
        _this._endHandleLayerOwner = t1;
        t1.pushHandleLayers$2(effectiveStartHandle, effectiveEndHandle);
        return;
      }
      _this._startHandleLayerOwner.pushHandleLayers$2(effectiveStartHandle, _null);
      t1 = _this.selectables;
      t2 = _this.currentSelectionEndIndex;
      if (!(t2 >= 0 && t2 < t1.length))
        return A.ioore(t1, t2);
      _this.set$_endHandleLayerOwner(t1[t2]);
      _this._endHandleLayerOwner.pushHandleLayers$2(_null, effectiveEndHandle);
    },
    getSelectedContent$0() {
      var t1, t2, _i, data,
        selections = A._setArrayType([], type$.JSArray_SelectedContent);
      for (t1 = this.selectables, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, A.throwConcurrentModificationError)(t1), ++_i) {
        data = t1[_i].getSelectedContent$0();
        if (data != null)
          C.JSArray_methods.add$1(selections, data);
      }
      t1 = selections.length;
      if (t1 === 0)
        return null;
      for (_i = 0, t2 = ""; _i < t1; ++_i)
        t2 += selections[_i].plainText;
      return new A.SelectedContent(t2.charCodeAt(0) == 0 ? t2 : t2);
    },
    handleSelectAll$1($event) {
      var t1, t2, _i, _this = this;
      for (t1 = _this.selectables, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, A.throwConcurrentModificationError)(t1), ++_i)
        _this.dispatchSelectionEventToChild$2(t1[_i], $event);
      _this.currentSelectionStartIndex = 0;
      _this.currentSelectionEndIndex = _this.selectables.length - 1;
      return C.SelectionResult_4;
    },
    handleSelectWord$1($event) {
      var t1, index, t2, t3, t4, existingGeometry, _this = this;
      for (t1 = $event.globalPosition, index = 0; t2 = _this.selectables, index < t2.length; ++index) {
        t2 = J.get$size$x(t2[index]);
        t3 = _this.selectables;
        if (!(index < t3.length))
          return A.ioore(t3, index);
        t3 = J.get$size$x(t3[index]);
        t4 = _this.selectables;
        if (!(index < t4.length))
          return A.ioore(t4, index);
        if (A.MatrixUtils_transformRect(J.getTransformTo$1$z(t4[index], null), new A.Rect(0, 0, 0 + t2._dx, 0 + t3._dy)).contains$1(0, t1)) {
          t1 = _this.selectables;
          if (!(index < t1.length))
            return A.ioore(t1, index);
          existingGeometry = J.get$value$z(t1[index]);
          t1 = _this.selectables;
          if (!(index < t1.length))
            return A.ioore(t1, index);
          _this.dispatchSelectionEventToChild$2(t1[index], $event);
          t1 = _this.selectables;
          if (!(index < t1.length))
            return A.ioore(t1, index);
          if (!J.get$value$z(t1[index]).$eq(0, existingGeometry)) {
            t1 = _this.selectables;
            t2 = A._arrayInstanceType(t1);
            new A.WhereIterable(t1, t2._eval$1("bool(1)")._as(new B.MultiSelectableSelectionContainerDelegate_handleSelectWord_closure(_this, index)), t2._eval$1("WhereIterable<1>")).forEach$1(0, new B.MultiSelectableSelectionContainerDelegate_handleSelectWord_closure0(_this));
            _this.currentSelectionStartIndex = _this.currentSelectionEndIndex = index;
          }
          return C.SelectionResult_2;
        }
      }
      return C.SelectionResult_4;
    },
    handleClearSelection$1($event) {
      var t1, t2, _i, _this = this;
      for (t1 = _this.selectables, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, A.throwConcurrentModificationError)(t1), ++_i)
        _this.dispatchSelectionEventToChild$2(t1[_i], $event);
      _this.currentSelectionStartIndex = _this.currentSelectionEndIndex = -1;
      return C.SelectionResult_4;
    },
    handleGranularlyExtendSelection$1($event) {
      var targetIndex, t2, result, t3, _this = this,
        t1 = _this.currentSelectionStartIndex;
      if (t1 === -1) {
        if ($event.forward) {
          _this.currentSelectionStartIndex = _this.currentSelectionEndIndex = 0;
          t1 = 0;
        } else {
          t1 = _this.selectables.length;
          _this.currentSelectionStartIndex = _this.currentSelectionEndIndex = t1;
        }
        targetIndex = t1;
      } else
        targetIndex = t1;
      t1 = $event.isEnd;
      if (t1)
        targetIndex = _this.currentSelectionEndIndex;
      t2 = _this.selectables;
      if (!(targetIndex >= 0 && targetIndex < t2.length))
        return A.ioore(t2, targetIndex);
      result = _this.dispatchSelectionEventToChild$2(t2[targetIndex], $event);
      if ($event.forward)
        while (true) {
          t2 = _this.selectables;
          t3 = t2.length;
          if (!(targetIndex < t3 - 1 && result === C.SelectionResult_0))
            break;
          ++targetIndex;
          if (!(targetIndex < t3))
            return A.ioore(t2, targetIndex);
          result = _this.dispatchSelectionEventToChild$2(t2[targetIndex], $event);
        }
      else
        while (true) {
          if (!(targetIndex > 0 && result === C.SelectionResult_1))
            break;
          --targetIndex;
          t2 = _this.selectables;
          if (!(targetIndex >= 0 && targetIndex < t2.length))
            return A.ioore(t2, targetIndex);
          result = _this.dispatchSelectionEventToChild$2(t2[targetIndex], $event);
        }
      if (t1)
        _this.currentSelectionEndIndex = targetIndex;
      else
        _this.currentSelectionStartIndex = targetIndex;
      return result;
    },
    handleDirectionallyExtendSelection$1($event) {
      var targetIndex, t2, result, _this = this,
        t1 = _this.currentSelectionStartIndex;
      if (t1 === -1) {
        switch ($event.direction.index) {
          case 0:
          case 3:
            t1 = _this.selectables.length;
            _this.currentSelectionStartIndex = _this.currentSelectionEndIndex = t1;
            break;
          case 1:
          case 2:
            _this.currentSelectionStartIndex = _this.currentSelectionEndIndex = 0;
            t1 = 0;
            break;
        }
        targetIndex = t1;
      } else
        targetIndex = t1;
      t1 = $event.isEnd;
      if (t1)
        targetIndex = _this.currentSelectionEndIndex;
      t2 = _this.selectables;
      if (!(targetIndex >= 0 && targetIndex < t2.length))
        return A.ioore(t2, targetIndex);
      result = _this.dispatchSelectionEventToChild$2(t2[targetIndex], $event);
      switch ($event.direction.index) {
        case 0:
          if (result === C.SelectionResult_1)
            if (targetIndex > 0) {
              --targetIndex;
              t2 = _this.selectables;
              if (!(targetIndex < t2.length))
                return A.ioore(t2, targetIndex);
              result = _this.dispatchSelectionEventToChild$2(t2[targetIndex], $event.copyWith$1$direction(C.SelectionExtendDirection_3));
            }
          break;
        case 1:
          if (result === C.SelectionResult_0) {
            t2 = _this.selectables;
            if (targetIndex < t2.length - 1) {
              ++targetIndex;
              result = _this.dispatchSelectionEventToChild$2(t2[targetIndex], $event.copyWith$1$direction(C.SelectionExtendDirection_2));
            }
          }
          break;
        case 2:
        case 3:
          break;
      }
      if (t1)
        _this.currentSelectionEndIndex = targetIndex;
      else
        _this.currentSelectionStartIndex = targetIndex;
      return result;
    },
    handleSelectionEdgeUpdate$1($event) {
      var _this = this;
      if ($event.type === C.SelectionEventType_1)
        return _this.currentSelectionEndIndex === -1 ? _this._initSelection$2$isEnd($event, true) : _this._adjustSelection$2$isEnd($event, true);
      return _this.currentSelectionStartIndex === -1 ? _this._initSelection$2$isEnd($event, false) : _this._adjustSelection$2$isEnd($event, false);
    },
    dispatchSelectionEvent$1($event) {
      var result, _this = this,
        selectionWillbeInProgress = !($event instanceof B.ClearSelectionEvent);
      if (!_this._selectionInProgress && selectionWillbeInProgress)
        C.JSArray_methods.sort$1(_this.selectables, _this.get$_compareScreenOrder());
      _this._selectionInProgress = selectionWillbeInProgress;
      _this._isHandlingSelectionEvent = true;
      result = A._Cell$named("result");
      switch ($event.type.index) {
        case 0:
        case 1:
          _this._extendSelectionInProgress = false;
          result.__late_helper$_value = _this.handleSelectionEdgeUpdate$1(type$.SelectionEdgeUpdateEvent._as($event));
          break;
        case 2:
          _this._extendSelectionInProgress = false;
          result.__late_helper$_value = _this.handleClearSelection$1(type$.ClearSelectionEvent._as($event));
          break;
        case 3:
          _this._extendSelectionInProgress = false;
          result.__late_helper$_value = _this.handleSelectAll$1(type$.SelectAllSelectionEvent._as($event));
          break;
        case 4:
          _this._extendSelectionInProgress = false;
          result.__late_helper$_value = _this.handleSelectWord$1(type$.SelectWordSelectionEvent._as($event));
          break;
        case 5:
          _this._extendSelectionInProgress = true;
          result.__late_helper$_value = _this.handleGranularlyExtendSelection$1(type$.GranularlyExtendSelectionEvent._as($event));
          break;
        case 6:
          _this._extendSelectionInProgress = true;
          result.__late_helper$_value = _this.handleDirectionallyExtendSelection$1(type$.DirectionallyExtendSelectionEvent._as($event));
          break;
      }
      _this._isHandlingSelectionEvent = false;
      _this._updateSelectionGeometry$0();
      return result._readLocal$0();
    },
    dispose$0() {
      var t1, t2, t3, _i, _this = this;
      for (t1 = _this.selectables, t2 = t1.length, t3 = _this.get$_handleSelectableGeometryChange(), _i = 0; _i < t1.length; t1.length === t2 || (0, A.throwConcurrentModificationError)(t1), ++_i)
        J.removeListener$1$x(t1[_i], t3);
      _this.set$selectables(D.List_empty12);
      _this._scheduledSelectableUpdate = false;
      _this.super$ChangeNotifier$dispose();
    },
    dispatchSelectionEventToChild$2(selectable, $event) {
      return selectable.dispatchSelectionEvent$1($event);
    },
    _initSelection$2$isEnd($event, isEnd) {
      var t1, t2, _this = this, newIndex = -1,
        hasFoundEdgeIndex = false,
        result = null, index = 0;
      while (true) {
        t1 = _this.selectables;
        t2 = t1.length;
        if (!(index < t2 && !hasFoundEdgeIndex))
          break;
        if (!(index < t2))
          return A.ioore(t1, index);
        switch (_this.dispatchSelectionEventToChild$2(t1[index], $event).index) {
          case 0:
          case 4:
            newIndex = index;
            break;
          case 2:
            newIndex = index;
            hasFoundEdgeIndex = true;
            result = C.SelectionResult_2;
            break;
          case 1:
            if (index === 0) {
              newIndex = 0;
              result = C.SelectionResult_1;
            }
            if (result == null)
              result = C.SelectionResult_2;
            hasFoundEdgeIndex = true;
            break;
          case 3:
            newIndex = index;
            hasFoundEdgeIndex = true;
            result = D.SelectionResult_3;
            break;
        }
        ++index;
      }
      if (newIndex === -1)
        return C.SelectionResult_4;
      if (isEnd)
        _this.currentSelectionEndIndex = newIndex;
      else
        _this.currentSelectionStartIndex = newIndex;
      return result == null ? C.SelectionResult_0 : result;
    },
    _adjustSelection$2$isEnd($event, isEnd) {
      var t1, t2, finalResult0, _this = this,
        newIndex = isEnd ? _this.currentSelectionEndIndex : _this.currentSelectionStartIndex,
        currentSelectableResult = A._Cell$named("currentSelectableResult"),
        finalResult = null, $forward = null;
      while (true) {
        t1 = _this.selectables;
        t2 = t1.length;
        if (!(newIndex < t2 && newIndex >= 0 && finalResult == null))
          break;
        if (!(newIndex >= 0 && newIndex < t2))
          return A.ioore(t1, newIndex);
        finalResult0 = currentSelectableResult.__late_helper$_value = _this.dispatchSelectionEventToChild$2(t1[newIndex], $event);
        switch (finalResult0.index) {
          case 2:
          case 3:
          case 4:
            finalResult = finalResult0;
            break;
          case 0:
            if ($forward === false) {
              ++newIndex;
              finalResult = C.SelectionResult_2;
            } else if (newIndex === _this.selectables.length - 1)
              finalResult = finalResult0;
            else {
              ++newIndex;
              $forward = true;
            }
            break;
          case 1:
            if ($forward === true) {
              --newIndex;
              finalResult = C.SelectionResult_2;
            } else if (newIndex === 0)
              finalResult = finalResult0;
            else {
              --newIndex;
              $forward = false;
            }
            break;
        }
      }
      if (isEnd)
        _this.currentSelectionEndIndex = newIndex;
      else
        _this.currentSelectionStartIndex = newIndex;
      finalResult.toString;
      return finalResult;
    },
    set$selectables(selectables) {
      this.selectables = type$.List_Selectable._as(selectables);
    },
    set$_startHandleLayerOwner(_startHandleLayerOwner) {
      this._startHandleLayerOwner = type$.nullable_Selectable._as(_startHandleLayerOwner);
    },
    set$_endHandleLayerOwner(_endHandleLayerOwner) {
      this._endHandleLayerOwner = type$.nullable_Selectable._as(_endHandleLayerOwner);
    },
    set$_additions(_additions) {
      this._additions = type$.Set_Selectable._as(_additions);
    },
    compareOrder$2(arg0, arg1) {
      return this.get$compareOrder().call$2(arg0, arg1);
    }
  };
  B._MultiSelectableSelectionContainerDelegate_SelectionContainerDelegate_ChangeNotifier.prototype = {};
  B.SelectionContainer.prototype = {
    createState$0() {
      return new B._SelectionContainerState(A.LinkedHashSet_LinkedHashSet$_empty(type$.void_Function), null, false, C._StateLifecycle_0);
    }
  };
  B._SelectionContainerState.prototype = {
    initState$0() {
      var t1, t2, t3, _this = this;
      _this.super$State$initState();
      t1 = _this._widget;
      t2 = t1.delegate;
      t3 = _this._framework$_element;
      t3.toString;
      t2._selectionContainerContext = t3;
      _this.set$registrar(t1.registrar);
    },
    didUpdateWidget$1(oldWidget) {
      var t1, t2, t3, t4, listener, _this = this;
      type$.SelectionContainer._as(oldWidget);
      _this.super$State$didUpdateWidget(oldWidget);
      t1 = oldWidget.delegate;
      if (t1 !== _this._widget.delegate) {
        t1._selectionContainerContext = null;
        t2 = _this._selection_container$_listeners;
        t2.forEach$1(0, t1.get$removeListener(t1));
        t3 = _this._widget.delegate;
        t4 = _this._framework$_element;
        t4.toString;
        t3._selectionContainerContext = t4;
        t2.forEach$1(0, t3.get$addListener(t3));
        t1 = t1._selectionGeometry;
        t3 = _this._widget.delegate._selectionGeometry;
        if (!t1.$eq(0, t3))
          for (t1 = A._LinkedHashSetIterator$(t2, t2._collection$_modifications, A._instanceType(t2)._precomputed1), t2 = t1.$ti._precomputed1; t1.moveNext$0();) {
            listener = t1._collection$_current;
            (listener == null ? t2._as(listener) : listener).call$0();
          }
      }
      t1 = _this._widget;
      _this.set$registrar(t1.registrar);
    },
    didChangeDependencies$0() {
      this.super$State$didChangeDependencies();
      this._widget.toString;
    },
    addListener$1(_, listener) {
      type$.void_Function._as(listener);
      this._widget.delegate.addListener$1(0, listener);
      this._selection_container$_listeners.add$1(0, listener);
    },
    removeListener$1(_, listener) {
      type$.void_Function._as(listener);
      this._widget.delegate.removeListener$1(0, listener);
      this._selection_container$_listeners.remove$1(0, listener);
    },
    pushHandleLayers$2(startHandle, endHandle) {
      this._widget.delegate.pushHandleLayers$2(startHandle, endHandle);
    },
    getSelectedContent$0() {
      return this._widget.delegate.getSelectedContent$0();
    },
    dispatchSelectionEvent$1($event) {
      return this._widget.delegate.dispatchSelectionEvent$1($event);
    },
    get$value(_) {
      var t1 = this._widget;
      return t1.delegate._selectionGeometry;
    },
    getTransformTo$1(_, ancestor) {
      return this._framework$_element.get$renderObject().getTransformTo$1(0, ancestor);
    },
    get$size(_) {
      var t1 = this._framework$_element.get$renderObject();
      t1.toString;
      t1 = type$.RenderBox._as(t1)._size;
      t1.toString;
      return t1;
    },
    dispose$0() {
      var t1 = this._widget.delegate;
      t1._selectionContainerContext = null;
      this._selection_container$_listeners.forEach$1(0, t1.get$removeListener(t1));
      this.super$__SelectionContainerState_State_Selectable_SelectionRegistrant$dispose();
    },
    build$1(context) {
      var t1 = this._widget,
        t2 = t1.delegate;
      return B.SelectionRegistrarScope$(t1.child, t2);
    },
    $isListenable: 1,
    $isValueListenable: 1
  };
  B.SelectionRegistrarScope.prototype = {
    updateShouldNotify$1(oldWidget) {
      return type$.SelectionRegistrarScope._as(oldWidget).registrar != this.registrar;
    }
  };
  B.SelectionContainerDelegate.prototype = {
    get$containerSize() {
      var t1 = this._selectionContainerContext.get$renderObject();
      t1.toString;
      t1 = type$.RenderBox._as(t1)._size;
      t1.toString;
      return t1;
    },
    $isListenable: 1,
    $isValueListenable: 1,
    $isSelectionRegistrar: 1
  };
  B.__SelectionContainerState_State_Selectable.prototype = {};
  B.__SelectionContainerState_State_Selectable_SelectionRegistrant.prototype = {
    dispose$0() {
      this._selection$_removeSelectionRegistrarSubscription$0();
      this.super$State$dispose();
    }
  };
  var typesOffset = hunkHelpers.updateTypes(["~()", "~(Selectable)", "~(DragDownDetails)", "~(DragStartDetails)", "~(DragUpdateDetails)", "~(DragEndDetails)", "~(PointerSignalEvent)", "~(PointerEvent)", "bool(ScrollMetricsNotification)", "int(Selectable,Selectable)"]);
  B._ScrollableState_State_TickerProviderStateMixin_RestorationMixin_dispose_closure.prototype = {
    call$2(property, listener) {
      type$.RestorableProperty_nullable_Object._as(property);
      type$.void_Function._as(listener);
      if (!property._restoration0$_disposed)
        property.removeListener$1(0, listener);
    },
    $signature: 42
  };
  B.ScrollableState_setCanDrag_closure.prototype = {
    call$0() {
      var t1 = this.$this.__ScrollableState__configuration_A;
      t1 === $ && A.throwLateFieldNI("_configuration");
      return A.VerticalDragGestureRecognizer$(null, t1.get$dragDevices());
    },
    $signature: 132
  };
  B.ScrollableState_setCanDrag_closure0.prototype = {
    call$1(instance) {
      var t1, t2, t3, _null = null;
      type$.VerticalDragGestureRecognizer._as(instance);
      t1 = this.$this;
      instance.set$onDown(t1.get$_handleDragDown());
      instance.set$onStart(0, t1.get$_scrollable$_handleDragStart());
      instance.set$onUpdate(t1.get$_scrollable$_handleDragUpdate());
      instance.set$onEnd(0, t1.get$_scrollable$_handleDragEnd());
      instance.set$onCancel(0, t1.get$_scrollable$_handleDragCancel());
      t2 = t1._physics;
      instance.minFlingDistance = t2 == null ? _null : t2.get$minFlingDistance();
      t2 = t1._physics;
      instance.minFlingVelocity = t2 == null ? _null : t2.get$minFlingVelocity();
      t2 = t1._physics;
      instance.maxFlingVelocity = t2 == null ? _null : t2.get$maxFlingVelocity();
      t2 = t1.__ScrollableState__configuration_A;
      t2 === $ && A.throwLateFieldNI("_configuration");
      t3 = t1._framework$_element;
      t3.toString;
      instance.set$velocityTrackerBuilder(t2.velocityTrackerBuilder$1(t3));
      instance.dragStartBehavior = t1._widget.dragStartBehavior;
      t1 = t1._mediaQueryData;
      instance.gestureSettings = t1 == null ? _null : t1.gestureSettings;
    },
    $signature: 133
  };
  B.ScrollableState_setCanDrag_closure1.prototype = {
    call$0() {
      var t1 = this.$this.__ScrollableState__configuration_A;
      t1 === $ && A.throwLateFieldNI("_configuration");
      return A.HorizontalDragGestureRecognizer$(null, t1.get$dragDevices());
    },
    $signature: 134
  };
  B.ScrollableState_setCanDrag_closure2.prototype = {
    call$1(instance) {
      var t1, t2, t3, _null = null;
      type$.HorizontalDragGestureRecognizer._as(instance);
      t1 = this.$this;
      instance.set$onDown(t1.get$_handleDragDown());
      instance.set$onStart(0, t1.get$_scrollable$_handleDragStart());
      instance.set$onUpdate(t1.get$_scrollable$_handleDragUpdate());
      instance.set$onEnd(0, t1.get$_scrollable$_handleDragEnd());
      instance.set$onCancel(0, t1.get$_scrollable$_handleDragCancel());
      t2 = t1._physics;
      instance.minFlingDistance = t2 == null ? _null : t2.get$minFlingDistance();
      t2 = t1._physics;
      instance.minFlingVelocity = t2 == null ? _null : t2.get$minFlingVelocity();
      t2 = t1._physics;
      instance.maxFlingVelocity = t2 == null ? _null : t2.get$maxFlingVelocity();
      t2 = t1.__ScrollableState__configuration_A;
      t2 === $ && A.throwLateFieldNI("_configuration");
      t3 = t1._framework$_element;
      t3.toString;
      instance.set$velocityTrackerBuilder(t2.velocityTrackerBuilder$1(t3));
      instance.dragStartBehavior = t1._widget.dragStartBehavior;
      t1 = t1._mediaQueryData;
      instance.gestureSettings = t1 == null ? _null : t1.gestureSettings;
    },
    $signature: 135
  };
  B._ScrollableSelectionContainerDelegate__scheduleLayoutChange_closure.prototype = {
    call$1(timeStamp) {
      var t1;
      type$.Duration._as(timeStamp);
      t1 = this.$this;
      if (!t1._scheduledLayoutChange)
        return;
      t1._scheduledLayoutChange = false;
      t1._updateSelectionGeometry$0();
    },
    $signature: 3
  };
  B._ScrollableSelectionContainerDelegate_didChangeSelectables_closure.prototype = {
    call$2(key, value) {
      type$.Selectable._as(key);
      A._asDouble(value);
      return !this.selectableSet.contains$1(0, key);
    },
    $signature: 165
  };
  B._ScrollableSelectionContainerDelegate_didChangeSelectables_closure0.prototype = {
    call$2(key, value) {
      type$.Selectable._as(key);
      A._asDouble(value);
      return !this.selectableSet.contains$1(0, key);
    },
    $signature: 165
  };
  B.MultiSelectableSelectionContainerDelegate__scheduleSelectableUpdate_closure.prototype = {
    call$1(timeStamp) {
      var t1;
      type$.Duration._as(timeStamp);
      t1 = this.$this;
      if (!t1._scheduledSelectableUpdate)
        return;
      t1._scheduledSelectableUpdate = false;
      if (t1._additions._collection$_length !== 0)
        t1._flushAdditions$0();
      t1.didChangeSelectables$0();
    },
    $signature: 3
  };
  B.MultiSelectableSelectionContainerDelegate_handleSelectWord_closure.prototype = {
    call$1(target) {
      var t1, t2;
      type$.Selectable._as(target);
      t1 = this.$this.selectables;
      t2 = this.index;
      if (!(t2 < t1.length))
        return A.ioore(t1, t2);
      return target !== t1[t2];
    },
    $signature: 93
  };
  B.MultiSelectableSelectionContainerDelegate_handleSelectWord_closure0.prototype = {
    call$1(target) {
      return this.$this.dispatchSelectionEventToChild$2(type$.Selectable._as(target), D.ClearSelectionEvent_SelectionEventType_2);
    },
    $signature: 491
  };
  (function aliases() {
    var _ = B._ScrollableState_State_TickerProviderStateMixin.prototype;
    _.super$_ScrollableState_State_TickerProviderStateMixin$dispose = _.dispose$0;
    _ = B._ScrollableState_State_TickerProviderStateMixin_RestorationMixin.prototype;
    _.super$_ScrollableState_State_TickerProviderStateMixin_RestorationMixin$didUpdateWidget = _.didUpdateWidget$1;
    _.super$_ScrollableState_State_TickerProviderStateMixin_RestorationMixin$didChangeDependencies = _.didChangeDependencies$0;
    _.super$_ScrollableState_State_TickerProviderStateMixin_RestorationMixin$dispose = _.dispose$0;
    _ = B.MultiSelectableSelectionContainerDelegate.prototype;
    _.super$MultiSelectableSelectionContainerDelegate$remove = _.remove$1;
    _.super$MultiSelectableSelectionContainerDelegate$didChangeSelectables = _.didChangeSelectables$0;
    _.super$MultiSelectableSelectionContainerDelegate$handleSelectAll = _.handleSelectAll$1;
    _.super$MultiSelectableSelectionContainerDelegate$handleSelectWord = _.handleSelectWord$1;
    _.super$MultiSelectableSelectionContainerDelegate$handleClearSelection = _.handleClearSelection$1;
    _.super$MultiSelectableSelectionContainerDelegate$handleGranularlyExtendSelection = _.handleGranularlyExtendSelection$1;
    _.super$MultiSelectableSelectionContainerDelegate$handleDirectionallyExtendSelection = _.handleDirectionallyExtendSelection$1;
    _.super$MultiSelectableSelectionContainerDelegate$handleSelectionEdgeUpdate = _.handleSelectionEdgeUpdate$1;
    _.super$MultiSelectableSelectionContainerDelegate$dispose = _.dispose$0;
    _.super$MultiSelectableSelectionContainerDelegate$dispatchSelectionEventToChild = _.dispatchSelectionEventToChild$2;
    _ = B.__SelectionContainerState_State_Selectable_SelectionRegistrant.prototype;
    _.super$__SelectionContainerState_State_Selectable_SelectionRegistrant$dispose = _.dispose$0;
  })();
  (function installTearOffs() {
    var _instance_0_u = hunkHelpers._instance_0u,
      _instance_1_u = hunkHelpers._instance_1u,
      _instance_1_i = hunkHelpers._instance_1i,
      _instance_2_u = hunkHelpers._instance_2u;
    _instance_0_u(B.SelectionRegistrant.prototype, "get$_selection$_updateSelectionRegistrarSubscription", "_selection$_updateSelectionRegistrarSubscription$0", 0);
    var _;
    _instance_1_u(_ = B.ScrollableState.prototype, "get$_handleDragDown", "_handleDragDown$1", 2);
    _instance_1_u(_, "get$_scrollable$_handleDragStart", "_scrollable$_handleDragStart$1", 3);
    _instance_1_u(_, "get$_scrollable$_handleDragUpdate", "_scrollable$_handleDragUpdate$1", 4);
    _instance_1_u(_, "get$_scrollable$_handleDragEnd", "_scrollable$_handleDragEnd$1", 5);
    _instance_0_u(_, "get$_scrollable$_handleDragCancel", "_scrollable$_handleDragCancel$0", 0);
    _instance_0_u(_, "get$_disposeHold", "_disposeHold$0", 0);
    _instance_0_u(_, "get$_disposeDrag", "_disposeDrag$0", 0);
    _instance_1_u(_, "get$_receivedPointerSignal", "_receivedPointerSignal$1", 6);
    _instance_1_u(_, "get$_scrollable$_handlePointerScroll", "_scrollable$_handlePointerScroll$1", 7);
    _instance_1_u(_, "get$_handleScrollMetricsNotification", "_handleScrollMetricsNotification$1", 8);
    _instance_0_u(_ = B._ScrollableSelectionContainerDelegate.prototype, "get$_scheduleLayoutChange", "_scheduleLayoutChange$0", 0);
    _instance_0_u(_, "get$dispose", "dispose$0", 0);
    _instance_1_i(_ = B.MultiSelectableSelectionContainerDelegate.prototype, "get$add", "add$1", 1);
    _instance_1_i(_, "get$remove", "remove$1", 1);
    _instance_2_u(_, "get$_compareScreenOrder", "_compareScreenOrder$2", 9);
    _instance_0_u(_, "get$_handleSelectableGeometryChange", "_handleSelectableGeometryChange$0", 0);
    _instance_0_u(_, "get$dispose", "dispose$0", 0);
  })();
  (function inheritance() {
    var _mixinHard = hunkHelpers.mixinHard,
      _mixin = hunkHelpers.mixin,
      _inheritMany = hunkHelpers.inheritMany,
      _inherit = hunkHelpers.inherit;
    _inheritMany(A.Object, [B.SelectionRegistrant, B.SelectionEvent, B.RevealedOffset, B.EdgeDraggingAutoScroller, B.SelectionContainerDelegate, B.ScrollableDetails]);
    _inheritMany(B.SelectionEvent, [B.ClearSelectionEvent, B.SelectionEdgeUpdateEvent]);
    _inheritMany(A.Closure2Args, [B._ScrollableState_State_TickerProviderStateMixin_RestorationMixin_dispose_closure, B._ScrollableSelectionContainerDelegate_didChangeSelectables_closure, B._ScrollableSelectionContainerDelegate_didChangeSelectables_closure0]);
    _inheritMany(A.StatefulWidget, [B.Scrollable, B._ScrollableSelectionHandler, B.SelectionContainer]);
    _inheritMany(A.InheritedWidget, [B._ScrollableScope, B.SelectionRegistrarScope]);
    _inheritMany(A.State, [B._ScrollableState_State_TickerProviderStateMixin, B._ScrollableSelectionHandlerState, B.__SelectionContainerState_State_Selectable]);
    _inherit(B._ScrollableState_State_TickerProviderStateMixin_RestorationMixin, B._ScrollableState_State_TickerProviderStateMixin);
    _inherit(B.ScrollableState, B._ScrollableState_State_TickerProviderStateMixin_RestorationMixin);
    _inheritMany(A.Closure0Args, [B.ScrollableState_setCanDrag_closure, B.ScrollableState_setCanDrag_closure1]);
    _inheritMany(A.Closure, [B.ScrollableState_setCanDrag_closure0, B.ScrollableState_setCanDrag_closure2, B._ScrollableSelectionContainerDelegate__scheduleLayoutChange_closure, B.MultiSelectableSelectionContainerDelegate__scheduleSelectableUpdate_closure, B.MultiSelectableSelectionContainerDelegate_handleSelectWord_closure, B.MultiSelectableSelectionContainerDelegate_handleSelectWord_closure0]);
    _inherit(B._MultiSelectableSelectionContainerDelegate_SelectionContainerDelegate_ChangeNotifier, B.SelectionContainerDelegate);
    _inherit(B.MultiSelectableSelectionContainerDelegate, B._MultiSelectableSelectionContainerDelegate_SelectionContainerDelegate_ChangeNotifier);
    _inherit(B._ScrollableSelectionContainerDelegate, B.MultiSelectableSelectionContainerDelegate);
    _inherit(B._ScrollSemantics, A.SingleChildRenderObjectWidget);
    _inherit(B._RenderScrollSemantics, A.RenderProxyBox);
    _inherit(B._RestorableScrollOffset, A.RestorableValue);
    _inherit(B.__SelectionContainerState_State_Selectable_SelectionRegistrant, B.__SelectionContainerState_State_Selectable);
    _inherit(B._SelectionContainerState, B.__SelectionContainerState_State_Selectable_SelectionRegistrant);
    _mixinHard(B._ScrollableState_State_TickerProviderStateMixin, A.TickerProviderStateMixin);
    _mixinHard(B._ScrollableState_State_TickerProviderStateMixin_RestorationMixin, A.RestorationMixin);
    _mixin(B._MultiSelectableSelectionContainerDelegate_SelectionContainerDelegate_ChangeNotifier, A.ChangeNotifier);
    _mixin(B.__SelectionContainerState_State_Selectable, A.Selectable);
    _mixinHard(B.__SelectionContainerState_State_Selectable_SelectionRegistrant, B.SelectionRegistrant);
  })();
  A._Universe_addRules(init.typeUniverse, JSON.parse('{"ClearSelectionEvent":{"SelectionEvent":[]},"SelectionEdgeUpdateEvent":{"SelectionEvent":[]},"Scrollable":{"StatefulWidget":[],"Widget":[],"DiagnosticableTree":[]},"_ScrollableSelectionHandler":{"StatefulWidget":[],"Widget":[],"DiagnosticableTree":[]},"_ScrollableScope":{"InheritedWidget":[],"ProxyWidget":[],"Widget":[],"DiagnosticableTree":[]},"ScrollableState":{"TickerProviderStateMixin":["Scrollable"],"RestorationMixin":["Scrollable"],"State":["Scrollable"],"TickerProvider":[],"ScrollContext":[],"State.T":"Scrollable"},"_ScrollableSelectionHandlerState":{"State":["_ScrollableSelectionHandler"],"State.T":"_ScrollableSelectionHandler"},"_ScrollableSelectionContainerDelegate":{"SelectionContainerDelegate":[],"ValueListenable":["SelectionGeometry"],"ChangeNotifier":[],"Listenable":[],"SelectionRegistrar":[]},"_ScrollSemantics":{"SingleChildRenderObjectWidget":[],"RenderObjectWidget":[],"Widget":[],"DiagnosticableTree":[]},"_RenderScrollSemantics":{"RenderBox":[],"RenderObjectWithChildMixin":["RenderBox"],"RenderObject":[],"DiagnosticableTree":[],"AbstractNode":[],"HitTestTarget":[],"RenderObjectWithChildMixin.0":"RenderBox"},"_RestorableScrollOffset":{"RestorableValue":["double?"],"RestorableProperty":["double?"],"ChangeNotifier":[],"Listenable":[],"RestorableValue.T":"double?"},"MultiSelectableSelectionContainerDelegate":{"SelectionContainerDelegate":[],"ValueListenable":["SelectionGeometry"],"ChangeNotifier":[],"Listenable":[],"SelectionRegistrar":[]},"SelectionContainer":{"StatefulWidget":[],"Widget":[],"DiagnosticableTree":[]},"_SelectionContainerState":{"Selectable":[],"State":["SelectionContainer"],"ValueListenable":["SelectionGeometry"],"Listenable":[],"State.T":"SelectionContainer"},"SelectionRegistrarScope":{"InheritedWidget":[],"ProxyWidget":[],"Widget":[],"DiagnosticableTree":[]},"SelectionContainerDelegate":{"ValueListenable":["SelectionGeometry"],"Listenable":[],"SelectionRegistrar":[]}}'));
  var type$ = (function rtii() {
    var findType = A.findType;
    return {
      Axis: findType("Axis"),
      ClearSelectionEvent: findType("ClearSelectionEvent"),
      ContainerLayer: findType("ContainerLayer"),
      DirectionallyExtendSelectionEvent: findType("DirectionallyExtendSelectionEvent"),
      Duration: findType("Duration"),
      GestureRecognizerFactoryWithHandlers_HorizontalDragGestureRecognizer: findType("GestureRecognizerFactoryWithHandlers<HorizontalDragGestureRecognizer>"),
      GestureRecognizerFactoryWithHandlers_VerticalDragGestureRecognizer: findType("GestureRecognizerFactoryWithHandlers<VerticalDragGestureRecognizer>"),
      GestureRecognizerFactory_GestureRecognizer: findType("GestureRecognizerFactory<GestureRecognizer>"),
      GranularlyExtendSelectionEvent: findType("GranularlyExtendSelectionEvent"),
      HorizontalDragGestureRecognizer: findType("HorizontalDragGestureRecognizer"),
      Iterable_SemanticsNode: findType("Iterable<SemanticsNode>"),
      JSArray_Selectable: findType("JSArray<Selectable>"),
      JSArray_SelectedContent: findType("JSArray<SelectedContent>"),
      JSArray_SemanticsNode: findType("JSArray<SemanticsNode>"),
      LabeledGlobalKey_RawGestureDetectorState: findType("LabeledGlobalKey<RawGestureDetectorState>"),
      LabeledGlobalKey_State_StatefulWidget: findType("LabeledGlobalKey<State<StatefulWidget>>"),
      List_Selectable: findType("List<Selectable>"),
      Map_of_Type_and_GestureRecognizerFactory_GestureRecognizer: findType("Map<Type,GestureRecognizerFactory<GestureRecognizer>>"),
      NotificationListener_ScrollMetricsNotification: findType("NotificationListener<ScrollMetricsNotification>"),
      PointerScrollEvent: findType("PointerScrollEvent"),
      PointerScrollInertiaCancelEvent: findType("PointerScrollInertiaCancelEvent"),
      PointerSignalEvent: findType("PointerSignalEvent"),
      RenderBox: findType("RenderBox"),
      RenderIgnorePointer: findType("RenderIgnorePointer"),
      RenderSemanticsGestureHandler: findType("RenderSemanticsGestureHandler"),
      RestorableProperty_nullable_Object: findType("RestorableProperty<Object?>"),
      ScrollMetricsNotification: findType("ScrollMetricsNotification"),
      Scrollable: findType("Scrollable"),
      SelectAllSelectionEvent: findType("SelectAllSelectionEvent"),
      SelectWordSelectionEvent: findType("SelectWordSelectionEvent"),
      Selectable: findType("Selectable"),
      SelectionContainer: findType("SelectionContainer"),
      SelectionEdgeUpdateEvent: findType("SelectionEdgeUpdateEvent"),
      SelectionRegistrarScope: findType("SelectionRegistrarScope"),
      Set_Selectable: findType("Set<Selectable>"),
      Set_SemanticsAction: findType("Set<SemanticsAction>"),
      Type: findType("Type"),
      VerticalDragGestureRecognizer: findType("VerticalDragGestureRecognizer"),
      _RenderScrollSemantics: findType("_RenderScrollSemantics"),
      _ScrollableScope: findType("_ScrollableScope"),
      _ScrollableSelectionHandler: findType("_ScrollableSelectionHandler"),
      double: findType("double"),
      nullable_Selectable: findType("Selectable?"),
      void: findType("~"),
      void_Function: findType("~()"),
      void_Function_Duration: findType("~(Duration)")
    };
  })();
  (function constants() {
    var makeConstList = hunkHelpers.makeConstList;
    D.ClearSelectionEvent_SelectionEventType_2 = new B.ClearSelectionEvent(C.SelectionEventType_2);
    D.List_empty12 = A._setArrayType(makeConstList([]), type$.JSArray_Selectable);
    D.Offset_YZQ = new A.Offset(1 / 0, 1 / 0);
    D.SelectionGeometry_wEo0 = new A.SelectionGeometry(null, null, C.SelectionStatus_2, false);
    D.SelectionResult_3 = new A.SelectionResult(3, "pending");
    D.SemanticsTag_FIw = new A.SemanticsTag("RenderViewport.twoPane");
    D.SemanticsTag_bQQ = new A.SemanticsTag("RenderViewport.excludeFromScrolling");
  })();
};

$__dart_deferred_initializers__["ZHAgBVZ9lmfnL8MDHcHScFmfA+A="] = $__dart_deferred_initializers__.current
